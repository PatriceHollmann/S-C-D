import * as React from 'react';
export interface FlexibleProps {
	[key: string]: any
}

/**
 * This class is used internally by the pivot grid component.
 * 
 */
declare class PivotGridCell extends React.Component<PivotGridCellProps, any> { }
export interface PivotGridCellProps extends FlexibleProps {

	/**
	 * The value for the `text-align` of the cell content.
	 * 
	 */
	align?: string

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * An arbitrary CSS class to add to the cell's inner element (the element that
	 * typically contains the cell's text).
	 * 
	 */
	bodyCls?: string

	/**
	 * Additional CSS styles that will be rendered into the cell's inner element (the element
	 * that typically contains the cell's text).
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     bodyStyle: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     bodyStyle: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     bodyStyle: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	bodyStyle?: string | any

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * An arbitrary CSS class to add to the cell's outermost element.
	 * 
	 */
	cls?: string

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * Specify `false` to write HTML directly to the cell. Be aware that doing this
	 * can expose your application to security issues if that content is not known to
	 * be safe. User input can contain malicious content such as `script` tags and
	 * should be scrubbed before directly rendering that HTML.
	 * 
	 */
	encodeHtml?: boolean

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * This config accepts a format specification as would be used in a `Ext.Template`
	 * formatted token. For example `'round(2)'` to round numbers to 2 decimal places
	 * or `'date("Y-m-d")'` to format a Date.
	 * 
	 * In previous releases the `renderer` config had limited abilities to use one
	 * of the `Ext.util.Format` methods but `formatter` now replaces that usage and
	 * can also handle formatting parameters.
	 * 
	 * When the value begins with `"this."` (for example, `"this.foo(2)"`), the
	 * implied scope on which "foo" is found is the `scope` config for the column.
	 * 
	 * If the `scope` is not given, or implied using a prefix of `"this"`, then either the
	 * ViewController or the closest ancestor component configured
	 * as defaultListenerScope is assumed to be the object with the method.
	 * 
	 */
	formatter?: string

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A renderer is a method which can be used to transform data (value, appearance, etc.)
	 * before it is rendered.
	 * 
	 * For example:
	 * 
	 *      {
	 *          text: 'Some column',
	 *          dataIndex: 'fieldName',
	 * 
	 *          renderer: function (value, record) {
	 *              if (value === 1) {
	 *                  return '1 person';
	 *              }
	 *              return value + ' people';
	 *          }
	 *      }
	 * 
	 * If a string is supplied, it should be the name of a renderer method from the
	 * appropriate Ext.app.ViewController.
	 * 
	 * This config is only processed if the cell type is the default of
	 * Ext.grid.cell.Cell.
	 * 
	 * **Note** See Ext.grid.Grid documentation for other, better alternatives
	 * to rendering cell content.
	 * 
	 */
	renderer?: Function | string

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The scope to use when calling the renderer or formatter function.
	 * 
	 */
	scope?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * An Ext.XTemplate, or an XTemplate *definition string* to use
	 * to process a Ext.data.Model data to produce a cell's rendered
	 * value.
	 * 
	 * This config is only processed if the cell type is the default of
	 * Ext.grid.cell.Cell.
	 * 
	 * **Note** See Ext.grid.Grid documentation for other, better alternatives
	 * to rendering cell content.
	 * 
	 */
	tpl?: string | string[] | any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * The value of the dataIndex field of
	 * the associated record. Application code should not need to set this value.
	 * 
	 */
	value?: any

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * 
	 * A replacement value for 0.
	 * 
	 * If the cell value is 0 and you want to display it or hide it then you can define
	 * a not null value here.
	 * 
	 * Set it as an empty string if you want to hide cells that have 0s.
	 * 
	 */
	zeroValue?: string

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * This class is used internally by the pivot grid component.
 * 
 */
declare class PivotGridGroupCell extends React.Component<PivotGridGroupCellProps, any> { }
export interface PivotGridGroupCellProps extends FlexibleProps {

	/**
	 * The value for the `text-align` of the cell content.
	 * 
	 */
	align?: string

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * An arbitrary CSS class to add to the cell's inner element (the element that
	 * typically contains the cell's text).
	 * 
	 */
	bodyCls?: string

	/**
	 * Additional CSS styles that will be rendered into the cell's inner element (the element
	 * that typically contains the cell's text).
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     bodyStyle: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     bodyStyle: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     bodyStyle: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	bodyStyle?: string | any

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * An arbitrary CSS class to add to the cell's outermost element.
	 * 
	 */
	cls?: string

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * Specify `false` to write HTML directly to the cell. Be aware that doing this
	 * can expose your application to security issues if that content is not known to
	 * be safe. User input can contain malicious content such as `script` tags and
	 * should be scrubbed before directly rendering that HTML.
	 * 
	 */
	encodeHtml?: boolean

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * This config accepts a format specification as would be used in a `Ext.Template`
	 * formatted token. For example `'round(2)'` to round numbers to 2 decimal places
	 * or `'date("Y-m-d")'` to format a Date.
	 * 
	 * In previous releases the `renderer` config had limited abilities to use one
	 * of the `Ext.util.Format` methods but `formatter` now replaces that usage and
	 * can also handle formatting parameters.
	 * 
	 * When the value begins with `"this."` (for example, `"this.foo(2)"`), the
	 * implied scope on which "foo" is found is the `scope` config for the column.
	 * 
	 * If the `scope` is not given, or implied using a prefix of `"this"`, then either the
	 * ViewController or the closest ancestor component configured
	 * as defaultListenerScope is assumed to be the object with the method.
	 * 
	 */
	formatter?: string

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A renderer is a method which can be used to transform data (value, appearance, etc.)
	 * before it is rendered.
	 * 
	 * For example:
	 * 
	 *      {
	 *          text: 'Some column',
	 *          dataIndex: 'fieldName',
	 * 
	 *          renderer: function (value, record) {
	 *              if (value === 1) {
	 *                  return '1 person';
	 *              }
	 *              return value + ' people';
	 *          }
	 *      }
	 * 
	 * If a string is supplied, it should be the name of a renderer method from the
	 * appropriate Ext.app.ViewController.
	 * 
	 * This config is only processed if the cell type is the default of
	 * Ext.grid.cell.Cell.
	 * 
	 * **Note** See Ext.grid.Grid documentation for other, better alternatives
	 * to rendering cell content.
	 * 
	 */
	renderer?: Function | string

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The scope to use when calling the renderer or formatter function.
	 * 
	 */
	scope?: any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * An Ext.XTemplate, or an XTemplate *definition string* to use
	 * to process a Ext.data.Model data to produce a cell's rendered
	 * value.
	 * 
	 * This config is only processed if the cell type is the default of
	 * Ext.grid.cell.Cell.
	 * 
	 * **Note** See Ext.grid.Grid documentation for other, better alternatives
	 * to rendering cell content.
	 * 
	 */
	tpl?: string | string[] | any

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * The value of the dataIndex field of
	 * the associated record. Application code should not need to set this value.
	 * 
	 */
	value?: any

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * 
	 * A replacement value for 0.
	 * 
	 * If the cell value is 0 and you want to display it or hide it then you can define
	 * a not null value here.
	 * 
	 * Set it as an empty string if you want to hide cells that have 0s.
	 * 
	 */
	zeroValue?: string

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * 
 * The pivot grid helps you analyze your data.
 * 
 * Calculations can be done either in your browser using a Ext.pivot.matrix.Local
 * matrix or remotely on the server using a Ext.pivot.matrix.Remote matrix.
 * 
 * Example usage:
 * 
 *      {
 *          xtype:  'pivotgrid',
 *          matrix: {
 *              type: 'local',
 *              store: 'yourStoreId',    // or a store instance
 *              rowGrandTotalsPosition: 'first',
 *              leftAxis: [{
 *                  dataIndex: 'country',
 *                  direction: 'DESC',
 *                  header: 'Countries',
 *                  width: 150
 *              }],
 *              topAxis: [{
 *                  dataIndex: 'year',
 *                  direction: 'ASC'
 *              }],
 *              aggregate: [{
 *                  dataIndex: 'value',
 *                  header: 'Total',
 *                  aggregator: 'sum',
 *                  width: 120
 *              }]
 *          }
 *      }
 * 
 * 
 * The modern pivot grid could be styled using data binding as following:
 * 
 * ## ViewModel on rows
 * 
 * Let's have a look at this example:
 * 
 *      {
 *          xtype: 'pivotgrid',
 *          itemConfig: {
 *              viewModel: {
 *                  type: 'pivot-row-model'
 *              },
 *              bind: {
 *                  userCls: '{rowStyle}'
 *                  // or you can define a template
 *                  //userCls: '{record.isRowGroupHeader:pick("","pivotRowHeader")}'
 *              }
 *          }
 *          // ... more configs
 *      }
 * 
 * In the ViewModel we would declare a formula that will use the record data. The record
 * has all values that are displayed for that row and the following additional fields:
 * 
 * - isRowGroupHeader
 * - isRowGroupTotal
 * - isRowGrandTotal
 * - leftAxisKey: This is either the grand total key or a key that identifies the left axis item
 * 
 * All these properties can help us style the entire row without knowing anything about the generated columns.
 * 
 * In some case we may want to style positive and negative values generated in the pivot grid. This can be done
 * as following.
 * 
 *      {
 *          xtype: 'pivotgrid',
 *          itemConfig: {
 *              viewModel: {
 *                  type: 'default'
 *              }
 *          },
 *          topAxisCellConfig: {
 *              bind: {
 *                  userCls: '{value:sign("pivotCellNegative","pivotCellPositive")}'
 *              }
 *          }
 *          // ... more configs
 *      }
 * 
 * The following data is available for use in the bind template:
 * 
 * - column
 *      - isColGroupTotal: this tells us that the column for that specific cell is a group total
 *      - isColGrandTotal: this tells us that the column for that specific cell is a grand total
 * 
 * - value: cell value
 * 
 * **Note:** In such cases you cannot use formulas because the column and value are generated dynamically
 * and can't be replaced in formulas.
 * 
 * 
 * It is also possible to style a specific dimension from left axis or aggregate:
 * 
 *      {
 *          xtype: 'pivotgrid',
 *          itemConfig: {
 *              viewModel: {
 *                  type: 'default'
 *              }
 *          },
 *          matrix: {
 *              aggregate: [{
 *                  dataIndex:  'value',
 *                  aggregator: 'sum',
 *                  align:      'right',
 * 
 *                  cellConfig: {
 *                      bind: {
 *                          userCls: '{value:sign("pivotCellNegative","pivotCellPositive")}'
 *                      }
 *                  }
 *              },{
 *                  dataIndex:  'value',
 *                  aggregator: 'count'
 *              }],
 *              leftAxis: [{
 *                  dataIndex:  'person',
 *                  // This is used only when `viewLayoutType` is `outline`
 *                  cellConfig: {
 *                      bind: {
 *                          userCls: '{record.isRowGroupHeader::pick("","pivotRowHeader")}'
 *                      }
 *                  }
 *              },{
 *                  dataIndex:  'country'
 *              }]
 *              // ... more configs
 *          }
 *      }
 * 
 * 
 * ## ViewModel on cells
 * 
 * This scenario allows you to define formulas to use in cell binding. Be careful that this means that
 * each cell will have an own ViewModel and this may decrease the pivot grid performance. Use it only
 * if necessary.
 * 
 *      {
 *          xtype: 'pivotgrid',
 *          leftAxisCellConfig: {
 *              viewModel: {
 *                  type: 'default'
 *              },
 *              bind: {
 *                  userCls: '{record.isRowGroupHeader::pick("","pivotRowHeader")}'
 *              }
 *          },
 *          topAxisCellConfig: {
 *              viewModel: {
 *                  type: 'pivot-cell-model' // to be able to define your own formulas
 *              },
 *              bind: {
 *                  userCls: '{value:sign("pivotCellNegative","pivotCellPositive")}'
 *                  //userCls: '{column.isColGrandTotal:pick(null,"pivotCellGrandTotal")}'
 *                  //userCls: '{cellCls}
 *              }
 *          }
 *          // ... more configs
 *      }
 * 
 * This approach lets you use record, column and value in both bind templates and formulas.
 * 
 * 
 * If multiple aggregate dimensions are available and you want to style one of them you can define the
 * binding on that dimension like this:
 * 
 *      {
 *          xtype: 'pivotgrid',
 *          matrix: {
 *              aggregate: [{
 *                  dataIndex:  'value',
 *                  aggregator: 'sum',
 *                  align:      'right',
 * 
 *                  cellConfig: {
 *                      viewModel: {
 *                          type: 'pivot-cell-model'
 *                      },
 *                      bind: {
 *                          userCls: '{value:sign("pivotCellNegative","pivotCellPositive")}'
 *                          //userCls: '{column.isColGrandTotal:pick(null,"pivotCellGrandTotal")}'
 *                          //userCls: '{cellCls}
 *                      }
 *                  }
 *              },{
 *                  dataIndex:  'value',
 *                  aggregator: 'count'
 *              }]
 *              // ... more configs
 *          }
 *      }
 * 
 */
declare class PivotGrid extends React.Component<PivotGridProps, any> { }
export interface PivotGridProps extends FlexibleProps {

	/**
	 * The item from the cfg-items collection that will be active first. This is
	 * usually only meaningful in a Ext.layout.Card, where only one item can be active at a
	 * time. If passes a string, it will be assumed to be a Ext.ComponentQuery selector.
	 * 
	 */
	activeItem?: any | string | number

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, children will be destroyed as soon as they are removed
	 * from this container.
	 * 
	 */
	autoDestroy?: boolean

	/**
	 * May be set to `false` for improved layout performance if auto-sizing is not required.
	 * 
	 * Some versions of Safari, both desktop and mobile, have very slow performance
	 * if the application has deeply nested containers due to the following WebKit
	 * bug: https://bugs.webkit.org/show_bug.cgi?id=150445
	 * 
	 * Applications that experience performance issues in the affected versions of
	 * Safari may need to turn off autoSizing globally for all `Ext.Container` instances
	 * by placing the following override in the application's "overrides" directory:
	 * 
	 *     Ext.define('MyApp.overrides.Container', {
	 *         override: 'Ext.Container',
	 *         config: {
	 *             autoSize: false
	 *         }
	 *     });
	 * 
	 * Once auto-sizing support has turned off by default, it can be selectively
	 * turned back on only on those container instances that explicitly need auto-sizing
	 * behavior by setting `autoSize` to `true`.
	 * 
	 * This option can also be used to allow children to be sized in percentage
	 * units as a workaround for the following browser bug:
	 * https://bugs.webkit.org/show_bug.cgi?id=137730
	 * 
	 * To illustrate, the following example should render a 200px by 200px green box
	 * (the container) with a yellow box inside of it (the child item).  The child
	 * item's height and width are both set to `'50%'` so the child should render
	 * exactly 100px by 100px in size.
	 * 
	 *     <Container
	 *         height={200}
	 *         width={200}
	 *         style="background: green"
	 *     >
	 *         <Component
	 *             style="background: yellow"
	 *             height="50%"
	 *             width="50%"
	 *         />
	 *     </Container>
	 * 
	 * All browsers except for Safari render the previous example correctly, but
	 * Safari does not assign a height to the component.  To make percentage-sized
	 * children work in Safari, simply set `autoSize` to `false` on the container.
	 * 
	 * Since the underlying implementation works by absolutely positioning the container's
	 * body element, this option can only be used when the container is not
	 * "shrink wrapping" the content in either direction.  When `autoSize` is
	 * set to `false`, shrink wrapped dimension(s) will collapse to 0.
	 * 
	 */
	autoSize?: boolean

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * The amount of items we render additionally besides the ones currently visible.
	 * We try to prevent the rendering of items while scrolling until the next time you stop scrolling.
	 * If you scroll close to the end of the buffer, we start rendering individual items to always
	 * have the minimumBufferSize prepared.
	 * 
	 */
	bufferSize?: number

	/**
	 * The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to
	 * 'right' for buttons/fbar, 'left' for other toolbar types).
	 * 
	 * **NOTE:** The preferred way to specify toolbars is to use the items config specifying the docked
	 * config on the item. Instead of buttonAlign you would add the layout: { pack: 'start' | 'center' | 'end' }
	 * option to the docked item config.
	 * 
	 */
	buttonAlign?: string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * CSS class assigned to the grand totals.
	 * 
	 */
	clsGrandTotal?: string

	/**
	 * CSS class assigned to the group totals.
	 * 
	 */
	clsGroupTotal?: string

	/**
	 * Configure as `true` to display lines between grid cells.
	 * 
	 */
	columnLines?: boolean

	/**
	 * This is a config object which is used by columns in this grid to create their
	 * header menus.
	 * 
	 * The default column menu contains the following items.
	 * 
	 * - A "Sort Ascending" menu item
	 * - A "Sort Descending" menu item
	 * - A Columns menu item with each of the columns in a sub-menu of check items
	 *   that is used to hide or show each column.
	 * - A "Group by this field" menu item to enable grouping.
	 * - A "Show in groups" check menu item to enable/disable grouping.
	 * 
	 * These items have cfg!weight of `-100`, `-90` and `-80` respectively to
	 * place them at the start of the menu.
	 * 
	 * This can be configured as `null` to prevent columns from showing a column menu.
	 * 
	 */
	columnMenu?: any

	/**
	 * One or more Ext.grid.column.Column providing the header text for the
	 * column, a column menu, optional column header tools, and a definition of where the
	 * data for that column comes from.
	 * 
	 * Example snippet:
	 * 
	 *     <Grid title="Stock Prices" store={this.store} shadow grouped>
	 *         <Column text="Company" dataIndex="name" width="150"/>
	 *         <Column text="Price" width="85" dataIndex="price" formatter='usMoney'/>
	 *         <Column text="Change" width="100" dataIndex="priceChange" tpl={this.signTpl.bind(this, 'priceChange', '0.00')} cell={{ encodeHtml: false }}/>
	 *         <Column text="% Change" dataIndex="priceChangePct" tpl={this.signTpl.bind(this, 'priceChangePct', '0.00%')} cell={{ encodeHtml: false }}/>
	 *         <Column text="Last Updated" width="125" dataIndex="lastChange" formatter='date("m/d/Y")'/>
	 *     </Grid>
	 * 
	 * NOTE: The Column component or any column sub-component may be used.  i.e.:
	 * Ext.grid.column.Column
	 * 
	 * Ext.grid.column.Boolean
	 * 
	 * Ext.grid.column.Check
	 * 
	 * Ext.grid.column.Date
	 * 
	 * Ext.grid.column.Number
	 * 
	 * Ext.grid.column.RowNumberer
	 * 
	 * Ext.grid.column.Text
	 * 
	 * Ext.grid.column.Tree
	 * 
	 */
	columns?: any

	/**
	 * This config is used to control the internal Ext.Container created to
	 * manage this list's items. One common use for this is to apply a userCls
	 * to the item container.
	 * 
	 *      {
	 *          xtype: 'list',
	 *          container: {
	 *              userCls: 'mylist-cls'
	 *          },
	 *          ...
	 *      }
	 * 
	 */
	container?: any

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * 
	 * Specifies a child Component to receive focus when this Container's method-focus
	 * method is called. Should be a valid Ext.ComponentQuery selector.
	 * 
	 */
	defaultFocus?: string

	/**
	 * A set of default configurations to apply to all child Components in this Container.
	 * 
	 * It's often useful to specify defaults when creating more than one children with similar configurations. For
	 * example here we can specify that each child has a height of 20px and avoid repeating the declaration for each
	 * one:
	 * 
	 *     <Container
	 *         fullscreen
	 *         defaults={{
	 *             height: 20
	 *         }}
	 *     >
	 *         <Panel>Panel 1</Panel>
	 *         <Panel>Panel 2</Panel>
	 *     </Container>
	 * 
	 */
	defaults?: any

	/**
	 * The xtype used for the component based DataView. Defaults to dataitem.
	 * Note this is only used when useComponents is true.
	 * 
	 */
	defaultType?: string

	/**
	 * `true` to defer `emptyText` being applied until the store's first load.
	 * 
	 */
	deferEmptyText?: boolean

	/**
	 * When set to true, tapping on the DataView's background (i.e. not on
	 * an item in the DataView) will deselect any currently selected items.
	 * 
	 */
	deselectOnContainerClick?: boolean

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * A property to check on each record to display the disclosure on a per record basis.  This
	 * property must be false to prevent the disclosure from being displayed on the item.
	 * 
	 */
	disclosureProperty?: string

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The text to display in the view when there is no data to display
	 * 
	 */
	emptyText?: string

	/**
	 * Set this on false if you don't want to allow column sorting
	 * in the pivot grid generated columns.
	 * 
	 */
	enableColumnSort?: boolean

	/**
	 * Set this on false if you don't want to see the loading mask.
	 * 
	 */
	enableLoadMask?: boolean

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * Whether or not to group items in the provided Store with a header for each item.
	 * 
	 */
	grouped?: boolean

	/**
	 * A single string or an array of strings (optionally followed by an
	 * object containing template methods) used to create an `Ext.XTemplate`, or an
	 * `Ext.XTemplate` instance.
	 * 
	 * A single string:
	 * 
	 *       groupHeaderTpl: 'Group: {name}'
	 * 
	 * Using a string array (followed by an options object):
	 * 
	 *       groupHeaderTpl: [
	 *           'Group: ',
	 *           '<div>{name:this.formatName}</div>',
	 *           {
	 *               formatName: function(name) {
	 *                   return Ext.String.trim(name);
	 *               }
	 *           }
	 *       ]
	 * 
	 * The data object available to the template provides the following properties:
	 * 
	 *  * `name` The grouping string of the groupField
	 *    for the group header. This string is the string produced by grouper's
	 *    groupFn.
	 *  * `value` The value of the groupField
	 *    for the group header being rendered.
	 *  * `columnName` The column header associated with the field being grouped
	 *    by *if there is a column for the field*, falls back to the `groupField`.
	 *  * `groupField` The field name being grouped by.
	 *  * `html` The rendering of the `value` as handled by the cell (for a grid,
	 *    otherwise the same as `name`).
	 *  * `children` An array containing the child records for the group. **This is not
	 *    available if the store is a Ext.data.BufferedStore.**
	 * 
	 */
	groupHeaderTpl?: string | string[] | any

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * `true` to hide the grid column headers.
	 * 
	 */
	hideHeaders?: boolean

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * Set to `true` to render an alphabet IndexBar docked on the right. This can also
	 * be a config object for the Ext.dataview.IndexBar component.
	 * 
	 */
	indexBar?: boolean | any

	/**
	 * This List configuration should always be set to true on a Grid.
	 * 
	 */
	infinite?: boolean

	/**
	 * When set to `true` the items within the DataView will have their display set to inline-block
	 * and be arranged horizontally. By default the items will wrap to the width of the DataView.
	 * Passing an object with `{ wrap: false }` will turn off this wrapping behavior and overflowed
	 * items will need to be scrolled to horizontally.
	 * 
	 */
	inline?: boolean | any

	/**
	 * An additional CSS class to apply to items within the DataView.
	 * 
	 */
	itemCls?: string

	/**
	 * A configuration object that is passed to every item created by a component based DataView. Because each
	 * item that a DataView renders is a Component, we can pass configuration options to each component to
	 * easily customize how each child component behaves.
	 * 
	 * __Note:__ this is only used when `useComponents` is `true`.
	 * 
	 */
	itemConfig?: any

	/**
	 * This allows you to set the default item height and is used to roughly calculate the amount
	 * of items needed to fill the list. By default items are around 50px high.
	 * 
	 */
	itemHeight?: number

	/**
	 * The `tpl` to use for each of the items displayed in this DataView.
	 * 
	 */
	itemTpl?: string | string[] | any

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * Configuration for this Container's layout. Example:
	 * 
	 *     <Container
	 *         layout={{
	 *             type: "hbox",
	 *             align: "middle"
	 *         }}
	 *     >
	 *         <Panel
	 *             html="hello"
	 *             flex={1}
	 *             bodyStyle={{
	 *                 background: "#000",
	 *                 color: "#fff"
	 *             }}
	 *         />
	 *         <Panel
	 *             html="world"
	 *             flex={2}
	 *             bodyStyle={{
	 *                 background: "#f00",
	 *                 color: "#fff"
	 *             }}
	 *         />
	 *     </Container>
	 * 
	 */
	layout?: any | string

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * Cell configuration for columns generated for the left axis dimensions.
	 * 
	 * Binding could be defined here.
	 * 
	 */
	leftAxisCellConfig?: any

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * If specified, gives an explicit height for a cfg!floated data view when it is showing the loadingText,
	 * if that is specified. This is useful to prevent the view's height from collapsing to zero when the
	 * loading mask is applied and there are no other contents in the data view.
	 * 
	 */
	loadingHeight?: number

	/**
	 * A string to display during data load operations.  If specified, this text will be
	 * displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
	 * contents will continue to display normally until the new data is loaded and the contents are replaced.
	 * 
	 */
	loadingText?: string | boolean

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * A configuration to allow you to mask this container.
	 * You can optionally pass an object block with and xtype of `loadmask`, and an optional `message` value to
	 * display a loading mask. Please refer to the Ext.LoadMask component to see other configurations.
	 * 
	 *     <Container
	 *         html="Hello World"
	 *         masked={{
	 *             xtype: "loadmask",
	 *             message: "My Message"
	 *         }}
	 *     />
	 * 
	 * Alternatively, you can just call the setter at any time with `true`/`false` to show/hide the mask:
	 * 
	 *     setMasked(true); //show the mask
	 *     setMasked(false); //hides the mask
	 * 
	 * There are also two convenient methods, method-mask and unmask, to allow you to mask and unmask
	 * this container at any time.
	 * 
	 */
	masked?: boolean | any

	/**
	 * 
	 * This is the pivot matrix used by the pivot grid. All axis and aggregate dimensions should
	 * be defined here.
	 * 
	 * Example usage:
	 * 
	 *      {
	 *          xtype:  'pivotgrid',
	 *          matrix: {
	 *              type: 'local',
	 *              store: 'yourStoreId'    // or a store instance
	 *              rowGrandTotalsPosition: 'first',
	 *              leftAxis: [{
	 *                  dataIndex: 'country',
	 *                  direction: 'DESC',
	 *                  header: 'Countries'
	 *                  width: 150
	 *              }],
	 *              topAxis: [{
	 *                  dataIndex: 'year',
	 *                  direction: 'ASC'
	 *              }],
	 *              aggregate: [{
	 *                  dataIndex: 'value',
	 *                  header: 'Total',
	 *                  aggregator: 'sum',
	 *                  width: 120
	 *              }]
	 *          }
	 *      }
	 * 
	 */
	matrix: any

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * Maintains a cache of reusable components when using a component based DataView.  Improving performance at
	 * the cost of memory.
	 * 
	 * __Note:__ this is currently only used when `useComponents` is `true`.
	 * 
	 */
	maxItemCache?: number

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
	 * value for the Ext.Button#minWidth config of each Button added to the **footer toolbar** via the
	 * fbar or buttons configurations. It will be ignored for buttons that have a minWidth configured
	 * some other way, e.g. in their own config object or via the defaults of
	 * their parent container.
	 * 
	 */
	minButtonWidth?: number

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Configure as `true` to have columns remember their sorted state after other
	 * columns have been clicked upon to sort.
	 * 
	 * As subsequent columns are clicked upon, they become the new primary sort key.
	 * 
	 * The maximum number of sorters allowed in a Store is configurable via its
	 * underlying data collection. See Ext.util.Collection#multiSortLimit
	 * 
	 */
	multiColumnSort?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * `true` to display a disclosure icon on each list item.
	 * The list will still fire the disclose event, and the event can be stopped before itemtap.
	 * By setting this config to a function, the function passed will be called when the disclosure
	 * is tapped.
	 * Finally you can specify an object with a 'scope' and 'handler'
	 * property defined. This will also be bound to the tap event listener
	 * and is useful when you want to change the scope of the handler.
	 * 
	 */
	onItemDisclosure?: boolean | Function | string | any

	/**
	 * The padding to use on this Component. Can be specified as a number (in which
	 * case all edges get the same padding) or a CSS string like '5 10 10 10'
	 * 
	 */
	padding?: number | string

	/**
	 * Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience.
	 * 
	 */
	pinHeaders?: boolean

	/**
	 * A config object for the pinned header.  Only applicable when pinHeaders
	 * is `true`.
	 * 
	 */
	pinnedHeader?: any

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * The amount of delay between the `tapstart` and the moment we add the `pressedCls`.
	 * 
	 */
	pressedDelay?: number

	/**
	 * `true` to prevent the item selection when the user
	 * taps a disclose icon.
	 * 
	 */
	preventSelectionOnDisclose?: boolean

	record?: any

	/**
	 * Set this to false if you make many updates to your list (like in an interval), but updates
	 * won't affect the item's height. Doing this will increase the performance of these updates.
	 * 
	 */
	refreshHeightOnUpdate?: boolean

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * *only meaningful on platforms which has space-consuming scroll bars*
	 * 
	 * Configure as `true` to leave space for a scrollbar to appear even if the content does not
	 * overflow.
	 * 
	 * This is useful for trees which may expand and collapse causing visual flickering
	 * when scrollbars appear of disappear.
	 * 
	 */
	reserveScrollbar?: boolean

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Set this to `false` to suppress the borders in between the items in this list.
	 * By default the presence of borders in between the items is determined by the stylesheet.
	 * 
	 */
	rowLines?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The dock position of a list's child items relative to the list itself. Can be `top` or `bottom`.
	 * 
	 *     Ext.create('Ext.List', {
	 *          fullscreen: true,
	 *          itemTpl: '{firstName}',
	 *          data: [
	 *              { firstName: 'Peter'},
	 *              { firstName: 'Raymond'},
	 *              { firstName: 'Egon'},
	 *              { firstName: 'Winston'}
	 *          ],
	 *          items: [{
	 *               xtype: 'component',
	 *               html: 'Docked!',
	 *               docked: 'top'
	 *          },{
	 *               xtype: 'component',
	 *               html: 'Scroll Docked!',
	 *               scrollDock: 'top'
	 *          }]
	 *      });
	 * 
	 */
	scrollDock?: string

	/**
	 * Scroll the DataView to the top when the DataView is refreshed.
	 * 
	 */
	scrollToTopOnRefresh?: boolean

	/**
	 * A configuration object which allows passing of configuration options to create or
	 * reconfigure a Ext.dataview.selection.Model.
	 * 
	 * May contain the following options:
	 * 
	 *     - mode `'single'`, `'multi'` Allow selection of only a single or multiple *records*.
	 *     This is only valid when selecting cfg!rows.
	 *     - deselectable Configure as false to disallow deselecting down to zero selected *records*.
	 *     This is only valid when selecting cfg!rows.
	 *     - drag `true` or `false` to allow drag gestures to swipt a rage of cells or rows.
	 *     - columns `true` to enable column selection by clicking on headers. Defaults to `false`
	 *     - cells `true` to enable cell selection by clicking or dragging on cells. Defaults to `false`
	 *     - rows Set to `false` to disable selecting rows. Defaults to `true`
	 *     - checkbox `true` to add a checkbox column to display selected state. `'only'` to indicate
	 *     that only clicks on the checkbox affect row selected state.
	 *     - extensible `true` to enable the selection to be extended either in the `X` or `Y` axis
	 *     or `'x'` or `'y'` to configure
	 * 
	 */
	selectable?: any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Configure as `false` to disable column sorting via clicking the header and via
	 * the Sorting menu items.
	 * 
	 */
	sortable?: boolean

	/**
	 * Should the col groups be expanded on first init?
	 * 
	 */
	startColGroupsCollapsed?: boolean

	/**
	 * Should the row groups be expanded on first init?
	 * 
	 */
	startRowGroupsCollapsed?: boolean

	/**
	 * Can be either a Store instance or a configuration object that will be turned into a Store. The Store is used
	 * to populate the set of items that will be rendered in the DataView. See the DataView intro documentation for
	 * more information about the relationship between Store and DataView.
	 * 
	 */
	store: any

	/**
	 * Set this to true if you want the items in the list to be zebra striped, alternating their
	 * background color.
	 * 
	 */
	striped?: boolean

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The title that will be displayed in the TitleBar at the top of this Grid.
	 * 
	 */
	title?: string

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Cell configuration for columns generated for the top axis and aggregate dimensions.
	 * 
	 * Binding could be defined here.
	 * 
	 */
	topAxisCellConfig?: any

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * Determines what type of touch event is recognized as a touch on the container.
	 * Valid options are 'tap' and 'singletap'.
	 * 
	 */
	triggerCtEvent?: string

	/**
	 * Determines what type of touch event causes an item to be selected.
	 * Valid options are: 'itemtap', 'itemsingletap',
	 * 'itemdoubletap', 'itemswipe', 'itemtaphold', 'itemlongpress'.
	 * 
	 */
	triggerEvent?: string

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	useComponents?: boolean

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * Set this to true if you just want to have the list create simple items that use the itemTpl.
	 * These simple items still support headers, grouping and disclosure functionality but avoid
	 * container layouts and deeply nested markup. For many Lists using this configuration will
	 * drastically increase the scrolling and render performance.
	 * 
	 */
	useSimpleItems?: boolean

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * If set to `true`, then child cfg!items may be specified as a object,
	 * with each property name specifying an cfg!itemId, and the property
	 * value being the child item configuration object.
	 * 
	 * When using this scheme, each child item may contain a cfg!weight
	 * configuration value which affects its order in this container. Lower weights
	 * are towards the start, higher weights towards the end.
	 * 
	 */
	weighted?: boolean

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires whenever item within the Container is activated.
	 * 
	 */
	onActivate?: (newActiveItem: any, me: any, oldActiveItem: any) => void

	/**
	 * This event fires when `cfg!activeItem` changes.
	 */
	onActiveItemChange?: (sender: any, value: any | string | number, oldValue: any | string | number) => void

	onAdd?: () => void

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!activeItem` changes.
	 */
	onBeforeActiveItemChange?: (sender: any, value: any | string | number, oldValue: any | string | number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * An event fired when an extension block is extended
	 * using a drag gesture. Only fired when the grid's `cfg!selectable`
	 * is configured with the extensible config.
	 * 
	 */
	onBeforeSelectionExtend?: (grid: any, An: any, extension: any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever a column is added to the Grid.
	 * 
	 */
	onColumnAdd?: (me: any, column: any, index: number) => void

	/**
	 * Fires whenever a column is hidden in the Grid.
	 * 
	 */
	onColumnHide?: (me: any, column: any) => void

	/**
	 * Fired when a column first creates its column menu. This is to allow plugins
	 * to access and manipulate the column menu.
	 * 
	 * There will be the two sort items, and a column hide/show item with a child menu of
	 * checkboxes. After this, developers may add custom enu items.
	 * 
	 * Menu items may be configured with a `weight` config, and those with the lowest weight
	 * gravitate to the top.
	 * 
	 * The sort ascending, sort descending, and hide columns items have weight -3, -2, and -1
	 * 
	 */
	onColumnMenuCreated?: (grid: any, column: any, menu: any) => void

	/**
	 * Fires whenever a column is moved in the grid.
	 * 
	 */
	onColumnMove?: (me: any, column: any, fromIndex: number, toIndex: number) => void

	/**
	 * Fires whenever a column is removed from the Grid.
	 * 
	 */
	onColumnRemove?: (me: any, column: any) => void

	/**
	 * Fires whenever a column is resized in the Grid.
	 * 
	 */
	onColumnResize?: (me: any, column: any, width: number) => void

	/**
	 * Fires whenever a column is shown in the Grid.
	 * 
	 */
	onColumnShow?: (me: any, column: any) => void

	/**
	 * Fires whenever a column is sorted in the Grid.
	 * 
	 */
	onColumnSort?: (me: any, column: any, direction: string) => void

	/**
	 * Fires whenever item within the Container is deactivated.
	 * 
	 */
	onDeactivate?: (oldActiveItem: any, me: any, newActiveItem: any) => void

	/**
	 * Fires whenever an item is deselected
	 * 
	 */
	onDeselect?: (me: any, records: any, supressed: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever a disclosure is handled
	 * 
	 */
	onDisclose?: (me: any, record: any, target: HTMLElement, index: number, e: any) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * Fires whenever a swipe action has been triggered from a list item.
	 * 
	 */
	onItemAction?: (me: any, index: number, record: any, action: string) => void

	/**
	 * Fires whenever an item is doubletapped
	 * 
	 */
	onItemDoubleTap?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item's longpress event fires
	 * 
	 */
	onItemLongPress?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever the mouse pointer moves over an item
	 * 
	 */
	onItemMouseEnter?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever the mouse pointer leaves an item
	 * 
	 */
	onItemMouseLeave?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is singletapped
	 * 
	 */
	onItemSingleTap?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is swiped
	 * 
	 */
	onItemSwipe?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is tapped
	 * 
	 */
	onItemTap?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item's taphold event fires
	 * 
	 */
	onItemTapHold?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item touch is cancelled
	 * 
	 */
	onItemTouchCancel?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is touched
	 * 
	 */
	onItemTouchEnd?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is moved
	 * 
	 */
	onItemTouchMove?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is touched
	 * 
	 */
	onItemTouchStart?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	onMove?: () => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires before the matrix is reconfigured.
	 * 
	 * Return false to stop reconfiguring the matrix.
	 * 
	 */
	onPivotBeforeReconfigure?: (matrix: any, config: any) => void

	/**
	 * Available only when using a Ext.pivot.matrix.Remote matrix.
	 * Fires before requesting data from the server side.
	 * Return false if you don't want to make the Ajax request.
	 * 
	 */
	onPivotBeforeRequest?: (matrix: any, params: any) => void

	/**
	 * Fires before grand total records are created in the pivot store.
	 * Push additional objects to the array if you need to create additional grand totals.
	 * 
	 */
	onPivotBuildTotals?: (matrix: any, totals: any[]) => void

	/**
	 * Fires after the matrix built the columns.
	 * 
	 */
	onPivotColumnsBuilt?: (matrix: any, columns: any[]) => void

	/**
	 * Fires when the matrix finished processing the records
	 * 
	 */
	onPivotDone?: (matrix: any) => void

	/**
	 * Fires when a double tap is detected on a pivot group cell.
	 * The pivot group cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotGroupCellDoubleTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap is detected on a pivot group cell.
	 * The pivot group cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotGroupCellTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap hold is detected on a pivot group cell.
	 * The pivot group cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotGroupCellTapHold?: (params: any, e: any) => void

	/**
	 * Fires when a pivot group is collapsed. Could be a row or col pivot group.
	 * 
	 * The same event is fired when all groups are collapsed but no group param is provided.
	 * 
	 */
	onPivotGroupCollapse?: (matrix: any, type: string, group: any) => void

	/**
	 * Fires when a double tap is detected on a pivot group element.
	 * The pivot group element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotGroupDoubleTap?: (params: any, e: any) => void

	/**
	 * Fires when a pivot group is expanded. Could be a row or col pivot group.
	 * 
	 * The same event is fired when all groups are expanded but no group param is provided.
	 * 
	 */
	onPivotGroupExpand?: (matrix: any, type: string, group: any) => void

	/**
	 * Fires when a tap is detected on a pivot group element.
	 * The pivot group element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 * Return false if you want to prevent expanding/collapsing that group.
	 * 
	 */
	onPivotGroupTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap hold is detected on a pivot group element.
	 * The pivot group element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotGroupTapHold?: (params: any, e: any) => void

	/**
	 * Fires when a double tap is detected on a pivot item cell.
	 * The pivot item cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotItemCellDoubleTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap is detected on a pivot item cell.
	 * The pivot item cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotItemCellTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap hold is detected on a pivot item cell.
	 * The pivot item cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotItemCellTapHold?: (params: any, e: any) => void

	/**
	 * Fires when a double tap is detected on a pivot item element.
	 * The pivot item element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotItemDoubleTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap is detected on a pivot item element.
	 * The pivot item element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotItemTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap hold is detected on a pivot item element.
	 * The pivot item element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotItemTapHold?: (params: any, e: any) => void

	/**
	 * Fires after the matrix built the store model.
	 * 
	 */
	onPivotModelBuilt?: (matrix: any, model: any) => void

	/**
	 * Fires during records processing.
	 * 
	 */
	onPivotProgress?: (matrix: any, index: number, total: number) => void

	/**
	 * Fires when the matrix is reconfigured.
	 * 
	 */
	onPivotReconfigure?: (matrix: any, config: any) => void

	/**
	 * Fires after the matrix built a pivot store record.
	 * 
	 */
	onPivotRecordBuilt?: (matrix: any, record: any) => void

	/**
	 * Available only when using a Ext.pivot.matrix.Remote matrix.
	 * Fires if there was any Ajax exception or the success value in the response was false.
	 * 
	 */
	onPivotRequestException?: (matrix: any, response: any) => void

	/**
	 * Fires when the matrix starts processing the records.
	 * 
	 */
	onPivotStart?: (matrix: any) => void

	/**
	 * Fires after the matrix built the pivot store.
	 * 
	 */
	onPivotStoreBuilt?: (matrix: any, store: any) => void

	/**
	 * Fires when a double tap is detected on a pivot grand total cell.
	 * The pivot total cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotTotalCellDoubleTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap is detected on a pivot grand total cell.
	 * The pivot total cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotTotalCellTap?: (params: any, e: any) => void

	/**
	 * Fires when a double tap is detected on a pivot grand total cell.
	 * The pivot total cell is the one that belongs to the columns generated for the top axis dimensions.
	 * 
	 */
	onPivotTotalCellTapHold?: (params: any, e: any) => void

	/**
	 * Fires when a double tap is detected on a pivot grand total element.
	 * The pivot grand total element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotTotalDoubleTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap is detected on a pivot grand total element.
	 * The pivot grand total element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotTotalTap?: (params: any, e: any) => void

	/**
	 * Fires when a tap hold is detected on a pivot grand total element.
	 * The pivot grand total element is the one that belongs to the columns generated for the left axis dimensions.
	 * 
	 */
	onPivotTotalTapHold?: (params: any, e: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires whenever the DataView is refreshed
	 * 
	 */
	onRefresh?: (me: any) => void

	onRemove?: () => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a selection changes and a Ext.data.virtual.Store is being used.
	 * 
	 */
	onRowSelection?: (view: any, selection: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever an item is selected
	 * 
	 */
	onSelect?: (me: any, records: any) => void

	/**
	 * Fires when a selection changes.
	 * 
	 */
	onSelectionChange?: (view: any, records: any, selected: boolean, selection: any) => void

	/**
	 * An event fired when an extension block is dragged to
	 * encompass a new range. Only fired when the grid's `cfg!selectable`
	 * is configured with the extensible config.
	 * 
	 */
	onSelectionExtenderDrag?: (grid: any, An: any, extension: any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * This class is used for creating a configurator field component.
 * 
 */
declare class PivotConfigField extends React.Component<PivotConfigFieldProps, any> { }
export interface PivotConfigFieldProps extends FlexibleProps {
}

/**
 * This is a container that holds configurator fields.
 * 
 */
declare class PivotConfigContainer extends React.Component<PivotConfigContainerProps, any> { }
export interface PivotConfigContainerProps extends FlexibleProps {

	/**
	 * The item from the cfg-items collection that will be active first. This is
	 * usually only meaningful in a Ext.layout.Card, where only one item can be active at a
	 * time. If passes a string, it will be assumed to be a Ext.ComponentQuery selector.
	 * 
	 */
	activeItem?: any | string | number

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, children will be destroyed as soon as they are removed
	 * from this container.
	 * 
	 */
	autoDestroy?: boolean

	/**
	 * May be set to `false` for improved layout performance if auto-sizing is not required.
	 * 
	 * Some versions of Safari, both desktop and mobile, have very slow performance
	 * if the application has deeply nested containers due to the following WebKit
	 * bug: https://bugs.webkit.org/show_bug.cgi?id=150445
	 * 
	 * Applications that experience performance issues in the affected versions of
	 * Safari may need to turn off autoSizing globally for all `Ext.Container` instances
	 * by placing the following override in the application's "overrides" directory:
	 * 
	 *     Ext.define('MyApp.overrides.Container', {
	 *         override: 'Ext.Container',
	 *         config: {
	 *             autoSize: false
	 *         }
	 *     });
	 * 
	 * Once auto-sizing support has turned off by default, it can be selectively
	 * turned back on only on those container instances that explicitly need auto-sizing
	 * behavior by setting `autoSize` to `true`.
	 * 
	 * This option can also be used to allow children to be sized in percentage
	 * units as a workaround for the following browser bug:
	 * https://bugs.webkit.org/show_bug.cgi?id=137730
	 * 
	 * To illustrate, the following example should render a 200px by 200px green box
	 * (the container) with a yellow box inside of it (the child item).  The child
	 * item's height and width are both set to `'50%'` so the child should render
	 * exactly 100px by 100px in size.
	 * 
	 *     <Container
	 *         height={200}
	 *         width={200}
	 *         style="background: green"
	 *     >
	 *         <Component
	 *             style="background: yellow"
	 *             height="50%"
	 *             width="50%"
	 *         />
	 *     </Container>
	 * 
	 * All browsers except for Safari render the previous example correctly, but
	 * Safari does not assign a height to the component.  To make percentage-sized
	 * children work in Safari, simply set `autoSize` to `false` on the container.
	 * 
	 * Since the underlying implementation works by absolutely positioning the container's
	 * body element, this option can only be used when the container is not
	 * "shrink wrapping" the content in either direction.  When `autoSize` is
	 * set to `false`, shrink wrapped dimension(s) will collapse to 0.
	 * 
	 */
	autoSize?: boolean

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * The amount of items we render additionally besides the ones currently visible.
	 * We try to prevent the rendering of items while scrolling until the next time you stop scrolling.
	 * If you scroll close to the end of the buffer, we start rendering individual items to always
	 * have the minimumBufferSize prepared.
	 * 
	 */
	bufferSize?: number

	/**
	 * The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to
	 * 'right' for buttons/fbar, 'left' for other toolbar types).
	 * 
	 * **NOTE:** The preferred way to specify toolbars is to use the items config specifying the docked
	 * config on the item. Instead of buttonAlign you would add the layout: { pack: 'start' | 'center' | 'end' }
	 * option to the docked item config.
	 * 
	 */
	buttonAlign?: string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * This config is used to control the internal Ext.Container created to
	 * manage this list's items. One common use for this is to apply a userCls
	 * to the item container.
	 * 
	 *      {
	 *          xtype: 'list',
	 *          container: {
	 *              userCls: 'mylist-cls'
	 *          },
	 *          ...
	 *      }
	 * 
	 */
	container?: any

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * 
	 * Specifies a child Component to receive focus when this Container's method-focus
	 * method is called. Should be a valid Ext.ComponentQuery selector.
	 * 
	 */
	defaultFocus?: string

	/**
	 * A set of default configurations to apply to all child Components in this Container.
	 * 
	 * It's often useful to specify defaults when creating more than one children with similar configurations. For
	 * example here we can specify that each child has a height of 20px and avoid repeating the declaration for each
	 * one:
	 * 
	 *     <Container
	 *         fullscreen
	 *         defaults={{
	 *             height: 20
	 *         }}
	 *     >
	 *         <Panel>Panel 1</Panel>
	 *         <Panel>Panel 2</Panel>
	 *     </Container>
	 * 
	 */
	defaults?: any

	/**
	 * The xtype used for the component based DataView. Defaults to dataitem.
	 * Note this is only used when useComponents is true.
	 * 
	 */
	defaultType?: string

	/**
	 * `true` to defer `emptyText` being applied until the store's first load.
	 * 
	 */
	deferEmptyText?: boolean

	/**
	 * When set to true, tapping on the DataView's background (i.e. not on
	 * an item in the DataView) will deselect any currently selected items.
	 * 
	 */
	deselectOnContainerClick?: boolean

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * A property to check on each record to display the disclosure on a per record basis.  This
	 * property must be false to prevent the disclosure from being displayed on the item.
	 * 
	 */
	disclosureProperty?: string

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The text to display in the view when there is no data to display
	 * 
	 */
	emptyText?: string

	/**
	 * Possible values:
	 * 
	 * - `all` = the container is the "all fields" area;
	 * - `aggregate` = the container is the "values" area;
	 * - `leftAxis` = the container is the "row values" area;
	 * - `topAxis` = the container is the "column values" area;
	 * 
	 */
	fieldType?: string

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * Whether or not to group items in the provided Store with a header for each item.
	 * 
	 */
	grouped?: boolean

	/**
	 * A single string or an array of strings (optionally followed by an
	 * object containing template methods) used to create an `Ext.XTemplate`, or an
	 * `Ext.XTemplate` instance.
	 * 
	 * A single string:
	 * 
	 *       groupHeaderTpl: 'Group: {name}'
	 * 
	 * Using a string array (followed by an options object):
	 * 
	 *       groupHeaderTpl: [
	 *           'Group: ',
	 *           '<div>{name:this.formatName}</div>',
	 *           {
	 *               formatName: function(name) {
	 *                   return Ext.String.trim(name);
	 *               }
	 *           }
	 *       ]
	 * 
	 * The data object available to the template provides the following properties:
	 * 
	 *  * `name` The grouping string of the groupField
	 *    for the group header. This string is the string produced by grouper's
	 *    groupFn.
	 *  * `value` The value of the groupField
	 *    for the group header being rendered.
	 *  * `columnName` The column header associated with the field being grouped
	 *    by *if there is a column for the field*, falls back to the `groupField`.
	 *  * `groupField` The field name being grouped by.
	 *  * `html` The rendering of the `value` as handled by the cell (for a grid,
	 *    otherwise the same as `name`).
	 *  * `children` An array containing the child records for the group. **This is not
	 *    available if the store is a Ext.data.BufferedStore.**
	 * 
	 */
	groupHeaderTpl?: string | string[] | any

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * Set to `true` to render an alphabet IndexBar docked on the right. This can also
	 * be a config object for the Ext.dataview.IndexBar component.
	 * 
	 */
	indexBar?: boolean | any

	/**
	 * Set this to false to render all items in this list, and render them relatively.
	 * Note that this configuration can not be dynamically changed after the list has instantiated.
	 * 
	 */
	infinite?: boolean

	/**
	 * When set to `true` the items within the DataView will have their display set to inline-block
	 * and be arranged horizontally. By default the items will wrap to the width of the DataView.
	 * Passing an object with `{ wrap: false }` will turn off this wrapping behavior and overflowed
	 * items will need to be scrolled to horizontally.
	 * 
	 */
	inline?: boolean | any

	/**
	 * An additional CSS class to apply to items within the DataView.
	 * 
	 */
	itemCls?: string

	/**
	 * A configuration object that is passed to every item created by a component based DataView. Because each
	 * item that a DataView renders is a Component, we can pass configuration options to each component to
	 * easily customize how each child component behaves.
	 * 
	 * __Note:__ this is only used when `useComponents` is `true`.
	 * 
	 */
	itemConfig?: any

	/**
	 * This allows you to set the default item height and is used to roughly calculate the amount
	 * of items needed to fill the list. By default items are around 50px high.
	 * 
	 */
	itemHeight?: number

	/**
	 * The `tpl` to use for each of the items displayed in this DataView.
	 * 
	 */
	itemTpl?: string | string[] | any

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * Configuration for this Container's layout. Example:
	 * 
	 *     <Container
	 *         layout={{
	 *             type: "hbox",
	 *             align: "middle"
	 *         }}
	 *     >
	 *         <Panel
	 *             html="hello"
	 *             flex={1}
	 *             bodyStyle={{
	 *                 background: "#000",
	 *                 color: "#fff"
	 *             }}
	 *         />
	 *         <Panel
	 *             html="world"
	 *             flex={2}
	 *             bodyStyle={{
	 *                 background: "#f00",
	 *                 color: "#fff"
	 *             }}
	 *         />
	 *     </Container>
	 * 
	 */
	layout?: any | string

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * If specified, gives an explicit height for a cfg!floated data view when it is showing the loadingText,
	 * if that is specified. This is useful to prevent the view's height from collapsing to zero when the
	 * loading mask is applied and there are no other contents in the data view.
	 * 
	 */
	loadingHeight?: number

	/**
	 * A string to display during data load operations.  If specified, this text will be
	 * displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
	 * contents will continue to display normally until the new data is loaded and the contents are replaced.
	 * 
	 */
	loadingText?: string | boolean

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * A configuration to allow you to mask this container.
	 * You can optionally pass an object block with and xtype of `loadmask`, and an optional `message` value to
	 * display a loading mask. Please refer to the Ext.LoadMask component to see other configurations.
	 * 
	 *     <Container
	 *         html="Hello World"
	 *         masked={{
	 *             xtype: "loadmask",
	 *             message: "My Message"
	 *         }}
	 *     />
	 * 
	 * Alternatively, you can just call the setter at any time with `true`/`false` to show/hide the mask:
	 * 
	 *     setMasked(true); //show the mask
	 *     setMasked(false); //hides the mask
	 * 
	 * There are also two convenient methods, method-mask and unmask, to allow you to mask and unmask
	 * this container at any time.
	 * 
	 */
	masked?: boolean | any

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * Maintains a cache of reusable components when using a component based DataView.  Improving performance at
	 * the cost of memory.
	 * 
	 * __Note:__ this is currently only used when `useComponents` is `true`.
	 * 
	 */
	maxItemCache?: number

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
	 * value for the Ext.Button#minWidth config of each Button added to the **footer toolbar** via the
	 * fbar or buttons configurations. It will be ignored for buttons that have a minWidth configured
	 * some other way, e.g. in their own config object or via the defaults of
	 * their parent container.
	 * 
	 */
	minButtonWidth?: number

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * `true` to display a disclosure icon on each list item.
	 * The list will still fire the disclose event, and the event can be stopped before itemtap.
	 * By setting this config to a function, the function passed will be called when the disclosure
	 * is tapped.
	 * Finally you can specify an object with a 'scope' and 'handler'
	 * property defined. This will also be bound to the tap event listener
	 * and is useful when you want to change the scope of the handler.
	 * 
	 */
	onItemDisclosure?: boolean | Function | string | any

	/**
	 * The padding to use on this Component. Can be specified as a number (in which
	 * case all edges get the same padding) or a CSS string like '5 10 10 10'
	 * 
	 */
	padding?: number | string

	/**
	 * Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience.
	 * 
	 */
	pinHeaders?: boolean

	/**
	 * A config object for the pinned header.  Only applicable when pinHeaders
	 * is `true`.
	 * 
	 */
	pinnedHeader?: any

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * The amount of delay between the `tapstart` and the moment we add the `pressedCls`.
	 * 
	 */
	pressedDelay?: number

	/**
	 * `true` to prevent the item selection when the user
	 * taps a disclose icon.
	 * 
	 */
	preventSelectionOnDisclose?: boolean

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Set this to false if you make many updates to your list (like in an interval), but updates
	 * won't affect the item's height. Doing this will increase the performance of these updates.
	 * 
	 */
	refreshHeightOnUpdate?: boolean

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Set this to `false` to suppress the borders in between the items in this list.
	 * By default the presence of borders in between the items is determined by the stylesheet.
	 * 
	 */
	rowLines?: boolean

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * The dock position of a list's child items relative to the list itself. Can be `top` or `bottom`.
	 * 
	 *     Ext.create('Ext.List', {
	 *          fullscreen: true,
	 *          itemTpl: '{firstName}',
	 *          data: [
	 *              { firstName: 'Peter'},
	 *              { firstName: 'Raymond'},
	 *              { firstName: 'Egon'},
	 *              { firstName: 'Winston'}
	 *          ],
	 *          items: [{
	 *               xtype: 'component',
	 *               html: 'Docked!',
	 *               docked: 'top'
	 *          },{
	 *               xtype: 'component',
	 *               html: 'Scroll Docked!',
	 *               scrollDock: 'top'
	 *          }]
	 *      });
	 * 
	 */
	scrollDock?: string

	/**
	 * Scroll the DataView to the top when the DataView is refreshed.
	 * 
	 */
	scrollToTopOnRefresh?: boolean

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Can be either a Store instance or a configuration object that will be turned into a Store. The Store is used
	 * to populate the set of items that will be rendered in the DataView. See the DataView intro documentation for
	 * more information about the relationship between Store and DataView.
	 * 
	 */
	store: any

	/**
	 * Set this to true if you want the items in the list to be zebra striped, alternating their
	 * background color.
	 * 
	 */
	striped?: boolean

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * Determines what type of touch event is recognized as a touch on the container.
	 * Valid options are 'tap' and 'singletap'.
	 * 
	 */
	triggerCtEvent?: string

	/**
	 * Determines what type of touch event causes an item to be selected.
	 * Valid options are: 'itemtap', 'itemsingletap',
	 * 'itemdoubletap', 'itemswipe', 'itemtaphold', 'itemlongpress'.
	 * 
	 */
	triggerEvent?: string

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	useComponents?: boolean

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * Set this to true if you just want to have the list create simple items that use the itemTpl.
	 * These simple items still support headers, grouping and disclosure functionality but avoid
	 * container layouts and deeply nested markup. For many Lists using this configuration will
	 * drastically increase the scrolling and render performance.
	 * 
	 */
	useSimpleItems?: boolean

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * If set to `true`, then child cfg!items may be specified as a object,
	 * with each property name specifying an cfg!itemId, and the property
	 * value being the child item configuration object.
	 * 
	 * When using this scheme, each child item may contain a cfg!weight
	 * configuration value which affects its order in this container. Lower weights
	 * are towards the start, higher weights towards the end.
	 * 
	 */
	weighted?: boolean

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires whenever item within the Container is activated.
	 * 
	 */
	onActivate?: (newActiveItem: any, me: any, oldActiveItem: any) => void

	/**
	 * This event fires when `cfg!activeItem` changes.
	 */
	onActiveItemChange?: (sender: any, value: any | string | number, oldValue: any | string | number) => void

	onAdd?: () => void

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!activeItem` changes.
	 */
	onBeforeActiveItemChange?: (sender: any, value: any | string | number, oldValue: any | string | number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever item within the Container is deactivated.
	 * 
	 */
	onDeactivate?: (oldActiveItem: any, me: any, newActiveItem: any) => void

	/**
	 * Fires whenever an item is deselected
	 * 
	 */
	onDeselect?: (me: any, records: any, supressed: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever a disclosure is handled
	 * 
	 */
	onDisclose?: (me: any, record: any, target: HTMLElement, index: number, e: any) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * Fires whenever a swipe action has been triggered from a list item.
	 * 
	 */
	onItemAction?: (me: any, index: number, record: any, action: string) => void

	/**
	 * Fires whenever an item is doubletapped
	 * 
	 */
	onItemDoubleTap?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item's longpress event fires
	 * 
	 */
	onItemLongPress?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever the mouse pointer moves over an item
	 * 
	 */
	onItemMouseEnter?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever the mouse pointer leaves an item
	 * 
	 */
	onItemMouseLeave?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is singletapped
	 * 
	 */
	onItemSingleTap?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is swiped
	 * 
	 */
	onItemSwipe?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is tapped
	 * 
	 */
	onItemTap?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item's taphold event fires
	 * 
	 */
	onItemTapHold?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item touch is cancelled
	 * 
	 */
	onItemTouchCancel?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is touched
	 * 
	 */
	onItemTouchEnd?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is moved
	 * 
	 */
	onItemTouchMove?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * Fires whenever an item is touched
	 * 
	 */
	onItemTouchStart?: (me: any, index: number, target: any, record: any, e: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	onMove?: () => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires whenever the DataView is refreshed
	 * 
	 */
	onRefresh?: (me: any) => void

	onRemove?: () => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a selection changes and a Ext.data.virtual.Store is being used.
	 * 
	 */
	onRowSelection?: (view: any, selection: any) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever an item is selected
	 * 
	 */
	onSelect?: (me: any, records: any) => void

	/**
	 * Fires when a selection changes.
	 * 
	 */
	onSelectionChange?: (view: any, records: any, selected: boolean, selection: any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * This class implements the configurator panel.
 * 
 */
declare class PivotConfigPanel extends React.Component<PivotConfigPanelProps, any> { }
export interface PivotConfigPanelProps extends FlexibleProps {

	/**
	 * The item from the cfg-items collection that will be active first. This is
	 * usually only meaningful in a Ext.layout.Card, where only one item can be active at a
	 * time. If passes a string, it will be assumed to be a Ext.ComponentQuery selector.
	 * 
	 */
	activeItem?: any | string | number

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, children will be destroyed as soon as they are removed
	 * from this container.
	 * 
	 */
	autoDestroy?: boolean

	/**
	 * May be set to `false` for improved layout performance if auto-sizing is not required.
	 * 
	 * Some versions of Safari, both desktop and mobile, have very slow performance
	 * if the application has deeply nested containers due to the following WebKit
	 * bug: https://bugs.webkit.org/show_bug.cgi?id=150445
	 * 
	 * Applications that experience performance issues in the affected versions of
	 * Safari may need to turn off autoSizing globally for all `Ext.Container` instances
	 * by placing the following override in the application's "overrides" directory:
	 * 
	 *     Ext.define('MyApp.overrides.Container', {
	 *         override: 'Ext.Container',
	 *         config: {
	 *             autoSize: false
	 *         }
	 *     });
	 * 
	 * Once auto-sizing support has turned off by default, it can be selectively
	 * turned back on only on those container instances that explicitly need auto-sizing
	 * behavior by setting `autoSize` to `true`.
	 * 
	 * This option can also be used to allow children to be sized in percentage
	 * units as a workaround for the following browser bug:
	 * https://bugs.webkit.org/show_bug.cgi?id=137730
	 * 
	 * To illustrate, the following example should render a 200px by 200px green box
	 * (the container) with a yellow box inside of it (the child item).  The child
	 * item's height and width are both set to `'50%'` so the child should render
	 * exactly 100px by 100px in size.
	 * 
	 *     <Container
	 *         height={200}
	 *         width={200}
	 *         style="background: green"
	 *     >
	 *         <Component
	 *             style="background: yellow"
	 *             height="50%"
	 *             width="50%"
	 *         />
	 *     </Container>
	 * 
	 * All browsers except for Safari render the previous example correctly, but
	 * Safari does not assign a height to the component.  To make percentage-sized
	 * children work in Safari, simply set `autoSize` to `false` on the container.
	 * 
	 * Since the underlying implementation works by absolutely positioning the container's
	 * body element, this option can only be used when the container is not
	 * "shrink wrapping" the content in either direction.  When `autoSize` is
	 * set to `false`, shrink wrapped dimension(s) will collapse to 0.
	 * 
	 */
	autoSize?: boolean

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to
	 * 'right' for buttons/fbar, 'left' for other toolbar types).
	 * 
	 * **NOTE:** The preferred way to specify toolbars is to use the items config specifying the docked
	 * config on the item. Instead of buttonAlign you would add the layout: { pack: 'start' | 'center' | 'end' }
	 * option to the docked item config.
	 * 
	 */
	buttonAlign?: string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * 
	 * Specifies a child Component to receive focus when this Container's method-focus
	 * method is called. Should be a valid Ext.ComponentQuery selector.
	 * 
	 */
	defaultFocus?: string

	/**
	 * A set of default configurations to apply to all child Components in this Container.
	 * 
	 * It's often useful to specify defaults when creating more than one children with similar configurations. For
	 * example here we can specify that each child has a height of 20px and avoid repeating the declaration for each
	 * one:
	 * 
	 *     <Container
	 *         fullscreen
	 *         defaults={{
	 *             height: 20
	 *         }}
	 *     >
	 *         <Panel>Panel 1</Panel>
	 *         <Panel>Panel 2</Panel>
	 *     </Container>
	 * 
	 */
	defaults?: any

	/**
	 * The default Ext.Component of child Components to create in this Container when a child item
	 * is specified as a raw configuration object, rather than as an instantiated Component.
	 * 
	 */
	defaultType?: string

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * Configuration for this Container's layout. Example:
	 * 
	 *     <Container
	 *         layout={{
	 *             type: "hbox",
	 *             align: "middle"
	 *         }}
	 *     >
	 *         <Panel
	 *             html="hello"
	 *             flex={1}
	 *             bodyStyle={{
	 *                 background: "#000",
	 *                 color: "#fff"
	 *             }}
	 *         />
	 *         <Panel
	 *             html="world"
	 *             flex={2}
	 *             bodyStyle={{
	 *                 background: "#f00",
	 *                 color: "#fff"
	 *             }}
	 *         />
	 *     </Container>
	 * 
	 */
	layout?: any | string

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * A configuration to allow you to mask this container.
	 * You can optionally pass an object block with and xtype of `loadmask`, and an optional `message` value to
	 * display a loading mask. Please refer to the Ext.LoadMask component to see other configurations.
	 * 
	 *     <Container
	 *         html="Hello World"
	 *         masked={{
	 *             xtype: "loadmask",
	 *             message: "My Message"
	 *         }}
	 *     />
	 * 
	 * Alternatively, you can just call the setter at any time with `true`/`false` to show/hide the mask:
	 * 
	 *     setMasked(true); //show the mask
	 *     setMasked(false); //hides the mask
	 * 
	 * There are also two convenient methods, method-mask and unmask, to allow you to mask and unmask
	 * this container at any time.
	 * 
	 */
	masked?: boolean | any

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
	 * value for the Ext.Button#minWidth config of each Button added to the **footer toolbar** via the
	 * fbar or buttons configurations. It will be ignored for buttons that have a minWidth configured
	 * some other way, e.g. in their own config object or via the defaults of
	 * their parent container.
	 * 
	 */
	minButtonWidth?: number

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * The padding to use on this Component. Can be specified as a number (in which
	 * case all edges get the same padding) or a CSS string like '5 10 10 10'
	 * 
	 */
	padding?: number | string

	/**
	 * Text displayed in the container reserved for all aggregate fields
	 * when docked to top or bottom.
	 * 
	 */
	panelAggFieldsText?: string

	/**
	 * Text displayed in the container reserved for all aggregate fields
	 * when docked to left or right.
	 * 
	 */
	panelAggFieldsTitle?: string

	/**
	 * Text displayed in the container reserved for all available fields
	 * when docked to top or bottom.
	 * 
	 */
	panelAllFieldsText?: string

	/**
	 * Text displayed in the container reserved for all available fields
	 * when docked to left or right.
	 * 
	 */
	panelAllFieldsTitle?: string

	/**
	 * Text displayed in the container reserved for all left axis fields
	 * when docked to top or bottom.
	 * 
	 */
	panelLeftFieldsText?: string

	/**
	 * Text displayed in the container reserved for all left axis fields
	 * when docked to left or right.
	 * 
	 */
	panelLeftFieldsTitle?: string

	/**
	 * Text displayed in the container reserved for all top axis fields
	 * when docked to top or bottom.
	 * 
	 */
	panelTopFieldsText?: string

	/**
	 * Text displayed in the container reserved for all top axis fields
	 * when docked to left or right.
	 * 
	 */
	panelTopFieldsTitle?: string

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * If set to `true`, then child cfg!items may be specified as a object,
	 * with each property name specifying an cfg!itemId, and the property
	 * value being the child item configuration object.
	 * 
	 * When using this scheme, each child item may contain a cfg!weight
	 * configuration value which affects its order in this container. Lower weights
	 * are towards the start, higher weights towards the end.
	 * 
	 */
	weighted?: boolean

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires whenever item within the Container is activated.
	 * 
	 */
	onActivate?: (newActiveItem: any, me: any, oldActiveItem: any) => void

	/**
	 * This event fires when `cfg!activeItem` changes.
	 */
	onActiveItemChange?: (sender: any, value: any | string | number, oldValue: any | string | number) => void

	/**
	 * Fires whenever item added to the Container.
	 * 
	 */
	onAdd?: (me: any, item: any, index: number) => void

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!activeItem` changes.
	 */
	onBeforeActiveItemChange?: (sender: any, value: any | string | number, oldValue: any | string | number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever item within the Container is deactivated.
	 * 
	 */
	onDeactivate?: (oldActiveItem: any, me: any, newActiveItem: any) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires whenever item moved within the Container.
	 * 
	 */
	onMove?: (me: any, item: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires whenever item removed from the Container.
	 * 
	 */
	onRemove?: (me: any, item: any, index: number) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}

/**
 * This class is used internally by the pivot grid component.
 * 
 */
declare class PivotGridRow extends React.Component<PivotGridRowProps, any> { }
export interface PivotGridRowProps extends FlexibleProps {

	/**
	 * An object containing ARIA attributes to be set
	 * on this Component's ARIA element. Use this to set the attributes that cannot be
	 * determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.
	 * 
	 * **Note** that this config is only meaningful at the Component rendering time,
	 * and setting it after that will do nothing.
	 * 
	 */
	ariaAttributes?: any

	/**
	 * DOM selector for a child element that is to be used
	 * as description for this Component, set in `aria-describedby` attribute.
	 * The selector works the same way as ariaLabelledBy.
	 * 
	 */
	ariaDescribedBy?: string

	/**
	 * ARIA label for this Component. It is best to use
	 * ariaLabelledBy option instead, because screen readers prefer
	 * `aria-labelledby` attribute to `aria-label`. ariaLabel and
	 * ariaLabelledBy config options are mutually exclusive.
	 * 
	 */
	ariaLabel?: string

	/**
	 * DOM selector for a child element that is to be used
	 * as label for this Component, set in `aria-labelledby` attribute.
	 * If the selector is by `#id`, the label element can be any existing element,
	 * not necessarily a child of the main Component element.
	 * 
	 * ariaLabelledBy and ariaLabel config options are
	 * mutually exclusive, and `ariaLabelledBy` has the higher precedence.
	 * 
	 */
	ariaLabelledBy?: string

	/**
	 * If `true`, then, when showBy or alignTo fallback on
	 * constraint violation only takes place along the major align axis.
	 * 
	 * That is, if alignment `"l-r"` is being used, and `axisLock: true` is used, then if constraints
	 * fail, only fallback to `"r-l"` is considered.
	 * 
	 */
	axisLock?: boolean

	/**
	 * A config object for this row's Ext.grid.RowBody.
	 * When a Ext.grid.plugin.RowExpander is used all row bodies
	 * begin collapsed, and can be expanded by clicking on the row expander icon.
	 * When no Row Expander is present row bodies are always expanded by default but
	 * can be collapsed programmatically using collapse.
	 * 
	 */
	body?: any

	/**
	 * 
	 * Enables or disables bordering on this component.
	 * The following values are accepted:
	 * 
	 * - `null` or `true (default): Do nothing and allow the border to be specified by the theme.
	 * - `false`: suppress the default border provided by the theme.
	 * 
	 * Please note that enabling bordering via this config will not add a `border-color`
	 * or `border-style` CSS property to the component; you provide the `border-color`
	 * and `border-style` via CSS rule or style configuration
	 * (if not already provide by the theme).
	 * 
	 */
	border?: boolean

	/**
	 * The absolute bottom position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	bottom?: number | string

	/**
	 * Configure this as `true` to have this Component centered within its Container.
	 * Setting this value to `true` will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	centered?: boolean

	/**
	 * The CSS class to add to this widget's element, in
	 * addition to the baseCls. In many cases, this property will be specified
	 * by the derived widget class. See userCls for adding additional CSS
	 * classes to widget instances (such as items in a Ext.Container).
	 * 
	 */
	cls?: string | string[]

	/**
	 * The configured element will automatically be
	 * added as the content of this component. When you pass a string, we expect it to be an element id.
	 * If the content element is hidden, we will automatically show it.
	 * 
	 */
	contentEl?: any | HTMLElement | string

	/**
	 * The initial set of data to apply to the `tpl` to
	 * update the content area of the Component.
	 * 
	 */
	data?: any

	/**
	 * A default ui to use for Ext.grid.cell.Base in this row.
	 * 
	 */
	defaultCellUI?: string

	/**
	 * Whether or not this component is disabled
	 * 
	 */
	disabled?: boolean

	/**
	 * The dock position of this component in its container. Can be `left`, `top`, `right` or `bottom`.
	 * 
	 * __Notes__
	 * 
	 * You must use a HTML5 doctype for docked `bottom` to work. To do this, simply add the following code to the HTML file:
	 * 
	 *     <!doctype html>
	 * 
	 * So your index.html file should look a little like this:
	 * 
	 *     <!doctype html>
	 *     <html>
	 *         <head>
	 *             <title>MY application title</title>
	 *             ...
	 * 
	 */
	docked?: string

	/**
	 * Configuration options to make this Component draggable
	 * 
	 */
	draggable?: any

	/**
	 * The name of a `boolean` field in the grid's record which is to be used to check expanded state.
	 * Note that this field should be `true` to indicate expanded, and `false` to indicate collapsed.
	 * By default the expanded state of a record is stored on the associated `grid` component allowing
	 * that record to have different expand/collapse states on a per-grid basis.
	 * 
	 */
	expandedField?: string

	/**
	 * CSS class that will be added to focused
	 * component's focusClsEl, and removed when component blurs.
	 * 
	 */
	focusCls?: string

	/**
	 * Force the component to take up 100% width and height available, by adding it
	 * to Ext.Viewport.
	 * 
	 */
	fullscreen?: boolean

	/**
	 * The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	height?: number | string

	/**
	 * Whether or not this Component is hidden (its CSS `display` property is set to `none`).
	 * 
	 * Defaults to `true` for floated Components.
	 * 
	 */
	hidden?: boolean

	/**
	 * Animation effect to apply when the Component is being hidden.  Typically you want to use an
	 * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	hideAnimation?: string | any

	/**
	 * When using a cfg!modal Component, setting this to `true`
	 * will hide the modal mask and the Container when the mask is tapped on.
	 * 
	 */
	hideOnMaskTap?: boolean

	/**
	 * Optional HTML content to render inside this Component, or a reference
	 * to an existing element on the page.
	 * 
	 */
	html?: string | any | HTMLElement

	/**
	 * An object containing handlers for keyboard events. The property names of this
	 * object are the key name and any modifiers. The values of the properties are the
	 * descriptors of how to handle each event.
	 * 
	 * The handler descriptor can be simply the handler function (either the
	 * literal function or the method name), or it can be an object with these
	 * properties:
	 * 
	 *  - `handler`: The function or its name to call to handle the event.
	 *  - `scope`: The this pointer context (can be "this" or "controller").
	 *  - `event`: An optional override of the key event to which to listen.
	 * 
	 * **Important:** Calls to `setKeyMap` do not replace the entire `keyMap` but
	 * instead update the provided mappings. That is, unless `null` is passed as the
	 * value of the `keyMap` which will clear the `keyMap` of all entries.
	 * 
	 */
	keyMap?: any

	/**
	 * Enables or disables processing keys in the `keyMap`. This value starts as
	 * `null` and if it is `null` when `initKeyMap` is called, it will automatically
	 * be set to `true`. Since `initKeyMap` is called by `Ext.Component` at the
	 * proper time, this is not something application code normally handles.
	 * 
	 */
	keyMapEnabled?: boolean

	/**
	 * The absolute left position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	left?: number | string

	/**
	 * 
	 * A config object containing one or more event handlers to be added to this object during initialization. This
	 * should be a valid listeners config object as specified in the
	 * addListener example for attaching
	 * multiple handlers at once.
	 * 
	 * **DOM events from Ext JS Ext.Component**
	 * 
	 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
	 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
	 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
	 * DOM listener to:
	 * 
	 *     new Ext.panel.Panel({
	 *         width: 400,
	 *         height: 200,
	 *         dockedItems: [{
	 *             xtype: 'toolbar'
	 *         }],
	 *         listeners: {
	 *             click: {
	 *                 element: 'el', //bind to the underlying el property on the panel
	 *                 fn: function(){ console.log('click el'); }
	 *             },
	 *             dblclick: {
	 *                 element: 'body', //bind to the underlying body property on the panel
	 *                 fn: function(){ console.log('dblclick body'); }
	 *             }
	 *         }
	 *     });
	 * 
	 */
	listeners?: any

	/**
	 * The margin to use on this Component. Can be specified as a number (in which case
	 * all edges get the same margin) or a CSS string like '5 10 10 10'
	 * 
	 */
	margin?: number | string

	/**
	 * The maximum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxHeight?: number | string

	/**
	 * The maximum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * Note that this config will not apply if the Component is 'positioned' (absolutely positioned or centered)
	 * 
	 */
	maxWidth?: number | string

	/**
	 * The minimum height of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minHeight?: number | string

	/**
	 * The minimum width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	minWidth?: number | string

	/**
	 * `true` to make this Component modal. This will create a mask underneath the Component
	 * that covers its parent and does not allow the user to interact with any other Components until this
	 * Component is dismissed.
	 * 
	 */
	modal?: boolean

	/**
	 * Name for the widget to be used with Ext.Container#lookupName et al.
	 * 
	 */
	name?: string

	/**
	 * The padding to use on this Component. Can be specified as a number (in which
	 * case all edges get the same padding) or a CSS string like '5 10 10 10'
	 * 
	 */
	padding?: number | string

	/**
	 * An object or array of objects that will provide custom functionality for this
	 * component. If a string is provided or a string is one of the elements of the
	 * array, that string is treated as the `type` alias. For example, "listpaging"
	 * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
	 * "plugin." prefix (i.e., 'plugin.listpaging').
	 * 
	 * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
	 * only requirement for a valid plugin is that it contain an `init()` method that
	 * accepts a reference to the owning component.
	 * 
	 * When a component is created, if any plugins are available, the component will
	 * call the `init` method on each plugin,
	 * passing a reference to itself. Each plugin can then call methods or respond to
	 * events on the component as needed to provide its functionality.
	 * 
	 * ## Example code
	 * 
	 * A plugin by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: 'listpaging'
	 *      });
	 * 
	 * Multiple plugins by alias:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: ['listpaging', 'pullrefresh']
	 *      });
	 * 
	 * Single plugin by class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }
	 *      });
	 * 
	 * Multiple plugins by type and class name with config options:
	 * 
	 *      var list = Ext.create({
	 *          xtype: 'list',
	 *          itemTpl: '<div class="item">{title}</div>',
	 *          store: 'Items',
	 * 
	 *          plugins: [{
	 *              xclass: 'Ext.plugin.PullRefresh',
	 *              pullRefreshText: 'Pull to refresh...'
	 *          }, {
	 *              type: 'listpaging',
	 *              autoPaging: true
	 *          }]
	 *      });
	 * 
	 */
	plugins?: any | string | any[] | string[]

	/**
	 * A model instance which updates the Component's html based on it's tpl. Similar to the data
	 * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
	 * instance and not a configuration of one.
	 * 
	 */
	record?: any

	/**
	 * Optional element to render this Component to.
	 * Not required if this component is an item of a Container of a Container.
	 * 
	 */
	renderTo?: any

	/**
	 * The absolute right position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	right?: number | string

	/**
	 * Configuration options to make this Component scrollable. Acceptable values are:
	 * 
	 * - `true` to enable auto scrolling.
	 * - `false` (or `null`) to disable scrolling - this is the default.
	 * - `x` or `horizontal` to enable horizontal scrolling only
	 * - `y` or `vertical` to enable vertical scrolling only
	 * 
	 * Also accepts a configuration object for a `Ext.scroll.Scroller` if
	 * if advanced configuration is needed.
	 * 
	 * The getter for this config returns the Ext.scroll.Scroller
	 * instance.  You can use the Scroller API to read or manipulate the scroll position:
	 * 
	 *     // scrolls the component to 5 on the x axis and 10 on the y axis
	 *     component.getScrollable().scrollTo(5, 10);
	 * 
	 */
	scrollable?: boolean | string | any

	/**
	 * Animation effect to apply when the Component is being shown.  Typically you want to use an
	 * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the Ext.fx.Animation#type config.
	 * 
	 */
	showAnimation?: string | any

	/**
	 * Additional CSS styles that will be rendered into an inline style attribute when
	 * the widget is rendered.
	 * 
	 * You can pass either a string syntax:
	 * 
	 *     style: 'background:red'
	 * 
	 * Or by using an object:
	 * 
	 *     style: {
	 *         background: 'red'
	 *     }
	 * 
	 * When using the object syntax, you can define CSS Properties by using a string:
	 * 
	 *     style: {
	 *         'border-left': '1px solid red'
	 *     }
	 * 
	 * Although the object syntax is much easier to read, we suggest you to use the
	 * string syntax for better performance.
	 * 
	 */
	style?: string | any

	/**
	 * DOM tabIndex attribute for this component's focusEl.
	 * 
	 */
	tabIndex?: number

	/**
	 * The Ext.tip.ToolTip for this component.
	 * 
	 *     <Button text="Basic Tip">
	 *         <ToolTip>A simple tooltip</ToolTip>
	 *     </Button>
	 * 
	 */
	tooltip?: any

	/**
	 * The absolute top position of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * Explicitly setting this value will make this Component become 'positioned', which means it will no
	 * longer participate in the layout of the Container that it resides in.
	 * 
	 */
	top?: number | string

	/**
	 * 
	 * Emulates the behavior of the CSS [touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
	 * property in a cross-browser compatible manner.
	 * 
	 * Keys in this object are touch action names, and values are `false` to disable
	 * a touch action or `true` to enable it.  Accepted keys are:
	 * 
	 * - `panX`
	 * - `panY`
	 * - `pinchZoom`
	 * - `doubleTapZoom`
	 * 
	 * All touch actions are enabled (`true`) by default, so it is usually only necessary
	 * to specify which touch actions to disable.  For example, the following disables
	 * only horizontal scrolling and pinch-to-zoom on the component's main element:
	 * 
	 *     touchAction: {
	 *         panX: false,
	 *         pinchZoom: false
	 *     }
	 * 
	 * Touch actions can be specified on reference elements using the reference element
	 * name, for example:
	 * 
	 *     // disables horizontal scrolling on the main element, and double-tap-zoom
	 *     // on the child element named "body"
	 *     touchAction: {
	 *         panY: false
	 *         body: {
	 *             doubleTapZoom: false
	 *         }
	 *     }
	 * 
	 * The primary motivation for setting the touch-action of an element is to prevent
	 * the browser's default handling of a gesture such as pinch-to-zoom, or
	 * drag-to-scroll, so that the application can implement its own handling of that
	 * gesture on the element.  Suppose, for example, a component has a custom drag
	 * handler on its element and wishes to prevent horizontal scrolling of its container
	 * while it is being dragged:
	 * 
	 *     Ext.create('Ext.Widget', {
	 *         touchAction: {
	 *             panX: false
	 *         },
	 *         listeners: {
	 *             drag: function(e) {
	 *                 // implement drag logic
	 *             }
	 *         }
	 *     });
	 * 
	 */
	touchAction?: any

	/**
	 * 
	 * A string, array of strings, or a function that returns JSX.
	 * 
	 *    tpl = data => <div>{data.first_name} {data.last_name}</div>
	 * 
	 * __Note__
	 * The data configuration _must_ be set for any content to be shown in the component when using this configuration.
	 * 
	 */
	tpl?: Function | string | string[]

	/**
	 * The Ext.(X)Template method to use when updating the content area of the Component.
	 * 
	 * Valid modes are:
	 * 
	 * - append
	 * - insertAfter
	 * - insertBefore
	 * - insertFirst
	 * - overwrite
	 * 
	 */
	tplWriteMode?: string

	/**
	 * The ui or uis to be used on this Component
	 * 
	 * When a ui is configured, CSS class names are added to the element, created
	 * by appending the ui name(s) to each classCls and/or baseCls.
	 * 
	 */
	ui?: string | string[]

	/**
	 * One or more CSS classes to add to the component's primary element. This config
	 * is intended solely for use by the component instantiator (the "user"), not by
	 * derived classes.
	 * 
	 * For example:
	 * 
	 *      items: [{
	 *          xtype: 'button',
	 *          userCls: 'my-button'
	 *      ...
	 *      }]
	 * 
	 */
	userCls?: string | string[]

	/**
	 * This value controls this item's order in a Ext.Container#cfg!weighted
	 * Ext.Container (see cfg!parent).
	 * 
	 * Lower values gravitate towards the start of the container - the top in vertical layouts, the
	 * locale start side in horizontal layouts.
	 * 
	 */
	weight?: number

	/**
	 * The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`, `30%`, etc.
	 * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
	 * If set to `auto`, it will set the width to `null` meaning it will have its own natural size.
	 * 
	 */
	width?: number | string

	/**
	 * The z-index to give this Component when it is rendered.
	 * 
	 * Not valid for cfg-floated Components. The Z ordering of cfg-floated
	 * Components is managed by ordering of the DOM elements.
	 * 
	 */
	zIndex?: number

	/**
	 * Fires after a Component had been added to a Container.
	 * 
	 */
	onAdded?: (me: any, container: any, index: number) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBeforeBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onBeforeCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onBeforeDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onBeforeDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onBeforeHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onBeforeHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeHide?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onBeforeLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onBeforeMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onBeforeMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onBeforeMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onBeforeMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onBeforeRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onBeforeScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
	 * 
	 */
	onBeforeShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onBeforeTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onBeforeWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when this Component's focusEl loses focus.
	 * 
	 */
	onBlur?: (me: any, event: any) => void

	/**
	 * This event fires when `cfg!bottom` changes.
	 */
	onBottomChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!centered` changes.
	 */
	onCenteredChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires when the component is destroyed
	 * 
	 */
	onDestroy?: () => void

	/**
	 * This event fires when `cfg!disabled` changes.
	 */
	onDisabledChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * This event fires when `cfg!docked` changes.
	 */
	onDockedChange?: (sender: any, value: string, oldValue: string) => void

	/**
	 * Fires when the component is no longer displayed in the DOM.  Listening to this event will
	 * degrade performance not recommend for general use.
	 * 
	 */
	onErased?: (me: any) => void

	/**
	 * Fires when this Component's focusEl receives focus.
	 * 
	 */
	onFocus?: (me: any, event: any) => void

	/**
	 * Fires when focus enters this Component's hierarchy.
	 * 
	 */
	onFocusEnter?: (me: any, event: any) => void

	/**
	 * Fires when focus leaves this Component's hierarchy.
	 * 
	 */
	onFocusLeave?: (me: any, event: any) => void

	/**
	 * Fires whenever a Component with the fullscreen config is instantiated
	 * 
	 */
	onFullscreen?: (me: any) => void

	/**
	 * This event fires when `cfg!height` changes.
	 */
	onHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!hidden` changes.
	 */
	onHiddenChange?: (sender: any, value: boolean, oldValue: boolean) => void

	/**
	 * Fires whenever the Component is hidden
	 * 
	 */
	onHide?: (me: any) => void

	/**
	 * Fires when the component has been initialized
	 * 
	 */
	onInitialize?: (me: any) => void

	/**
	 * This event fires when `cfg!left` changes.
	 */
	onLeftChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxHeight` changes.
	 */
	onMaxHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!maxWidth` changes.
	 */
	onMaxWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minHeight` changes.
	 */
	onMinHeightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!minWidth` changes.
	 */
	onMinWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * Fires when a component si moved within its Container.
	 * 
	 */
	onMoved?: (me: any, container: any, toIndex: number, fromIndex: number) => void

	/**
	 * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
	 * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
	 * 
	 * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
	 * add at least one listener to it, for performance reasons.
	 * 
	 */
	onPainted?: (element: any) => void

	/**
	 * Fires whenever there is a change in the positioned status of a component
	 * 
	 */
	onPositionedChange?: (me: any, positioned: boolean) => void

	/**
	 * Fires when a component is removed from a Container
	 * 
	 */
	onRemoved?: (me: any, container: any, index: number) => void

	/**
	 * Fires *asynchronously* after a browser layout caused by a component resize. This may be triggered for any or
	 * several of the following reasons:
	 *    - Programmatic changes to cfg-width or cfg-height configs.
	 *    - Setting the cfg-flex config when the owning layout is Ext.layout.Box.
	 *    - Setting cfg-minHeight, cfg-maxHeight, cfg-minWidth or cfg-maxWidth.
	 *    - Changing device orientation.
	 *    - Changing the browser viewport size.
	 *    - Any resize caused by browser layout recalculation which may be caused by content size changes
	 *      or application of default browser layout rules.
	 * 
	 */
	onResize?: (component: any, width: string | number, height: string | number, oldWidth: string | number, oldHeight: string | number) => void

	/**
	 * This event fires when `cfg!right` changes.
	 */
	onRightChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!scrollable` changes.
	 */
	onScrollableChange?: (sender: any, value: boolean | string | any, oldValue: boolean | string | any) => void

	/**
	 * Fires whenever the Component is shown
	 * 
	 */
	onShow?: (me: any) => void

	/**
	 * This event fires when `cfg!top` changes.
	 */
	onTopChange?: (sender: any, value: number | string, oldValue: number | string) => void

	/**
	 * This event fires when `cfg!width` changes.
	 */
	onWidthChange?: (sender: any, value: number | string, oldValue: number | string) => void
}