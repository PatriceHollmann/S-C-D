
export const bool = 'bool';

export const boolean = 'boolean';

/**
 * 
 * This class provides Date specific processing for fields.
 * 
 * In previous releases this functionality was integral to the `Field` base class.
 * 
 */
export const date = 'date';

/**
 * 
 * Fields are used to define the members of a Model. They aren't instantiated directly;
 * instead, when we create a class that extends Ext.data.Model, it automatically
 * creates Field instances for each field configured in a Ext.data.Model.
 * For example, we might set up a model like this:
 * 
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: [
 *             'name', 'email',
 *             { name: 'age', type: 'int' },
 *             { name: 'gender', type: 'string', defaultValue: 'Unknown' }
 *         ]
 *     });
 * 
 * Four fields will have been created for the User Model - name, email, age and gender.
 * Note that we specified a couple of different formats here; if we only pass in the string
 * name of the field (as with name and email), the field is set up with the 'auto' type.
 * It's as if we'd done this instead:
 * 
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: [
 *             { name: 'name', type: 'auto' },
 *             { name: 'email', type: 'auto' },
 *             { name: 'age', type: 'int' },
 *             { name: 'gender', type: 'string', defaultValue: 'Unknown' }
 *         ]
 *     });
 * 
 * # Field Types
 * 
 * Fields come in various types. When declaring a field, the `type` property is used to
 * specify the type of `Field` derived class used to manage values.
 * 
 * The predefined set of types are:
 * 
 *  - Ext.data.field.Field (Default, implies no conversion)
 *  - Ext.data.field.String
 *  - Ext.data.field.Integer
 *  - Ext.data.field.Number
 *  - Ext.data.field.Boolean
 *  - Ext.data.field.Date
 * 
 * # Conversion
 * 
 * When reading fields it is often necessary to convert the values received before using
 * them or storing them in records. To handle these cases there is the
 * `convert` method. This method is passed the received value (as
 * well as the current record instance, but see below) and it returns the value to carry
 * forward.
 * 
 * For `auto` fields there is no `convert` method. This is for
 * efficiency. For other field types, there are often `convert` methods. You can provide
 * a `convert` config when the field is defined like this:
 * 
 *      {
 *          name: 'timestamp',
 * 
 *          convert: function (value) {
 *              return new Date(value);
 *          }
 *      }
 * 
 * While this can be convenient, see below for details on defining Custom Types as that is
 * often a better practice and avoids repeating these functions.
 * 
 * Note that when a `defaultValue` is specified, it will also be passed through to
 * `convert` (either to the `convert` method or to the
 * `convert config)`.
 * 
 * ## Calculated Values
 * 
 * In some cases fields are the result of a calculation from other fields. Historically
 * this was a second role for `convert` but that has some short
 * comings. The simpler solution is the `calculate` config.
 * 
 * Values produced by `calculate` and `convert`
 * are stored in the record as with any other field. In fact, if we define a calculated
 * "firstName" field and log out all of the data, we'll see this:
 * 
 *     var ed = Ext.create('User', { name: 'Ed Spencer' });
 * 
 *     console.log(ed.data);
 * 
 *     //outputs this:
 *     {
 *         age: 0,
 *         email: "",
 *         firstName: "Ed",  // calculated field
 *         gender: "Unknown",
 *         name: "Ed Spencer"
 *     }
 * 
 * ### Using `calculate`
 * 
 *      {
 *          name: 'firstName',
 * 
 *          calculate: function (data) {
 *              return data.name.split(' ')[0];
 *          }
 *      }
 * 
 * Using `calculate` is the simplest and safest way to define a
 * calculated field. The most important part of this is that, internally, the code of the
 * supplied function is parsed to extract its dependencies. In this case, the "name" field
 * is the only dependency. This means that "firstName" will only need to be recalculated
 * when "name" is modified.
 * 
 * **Note:** Fields used by the calculate method must be explicitly defined in the
 * fields of the model.
 * 
 * ### Using `convert`
 * 
 * Following is the equivalent technique using `convert`
 * 
 *      {
 *          name: 'firstName',
 * 
 *          convert: function (value, record) {
 *              return record.get('name').split(' ')[0];
 *          },
 * 
 *          depends: [ 'name' ]
 *      }
 * 
 * When a `convert` function accepts a 2nd argument (a reference to
 * the record), it is considered a calculated field. If a `depends`
 * config is not provided then this field's dependencies are unknown. In this case, the
 * `depends` are provided as would be automatically determined with
 * the `calculate` config.
 * 
 * ### Updating
 * 
 * Fields modified with the set method will have their stored
 * value set using the convert / calculate method when present.
 * 
 * For example:
 * 
 *     Ext.define('MyApp.model.Employee', {
 *         extend: 'Ext.data.Model',
 *         fields: [{
 *             name: 'salary',
 *             convert: function (val) {
 *                 var startingBonus = val * .1;
 *                 return val + startingBonus;
 *             }
 *         }],
 *         convertOnSet: false
 *     });
 * 
 *     var tina = Ext.create('MyApp.model.Employee', {
 *         salary: 50000
 *     });
 * 
 *     console.log(tina.get('salary')); // logs 55000
 * 
 *     tina.set('salary', 60000);
 *     console.log(tina.get('salary')); // logs 60000
 * 
 * This default behavior can be disabled by setting the Model's
 * `Ext.data.Model#cfg-convertOnSet` config to `false`.
 * 
 * **Note:** convertOnSet `false` only prevents the convert / calculate call when the
 * set `fieldName` param matches the field's `name`.  See
 * convertOnSet for additional details.
 * 
 * ### Dependencies
 * 
 * When a field's `convert` method processes values from the record
 * (vs. just the field's value), it is best to also provide a `depends` config as shown
 * above. Fields that provide a `calculate` method must follow the
 * proper form for using fields so that dependencies can be extracted.
 * 
 * Calculated fields are processed after other fields based on their dependencies. Fields
 * with `convert` methods that use the provided record that do *not*
 * specify a `depends` config are processed as a group after all other
 * fields since such converters can rely on anything in the record. The order of processing
 * these fields with respect to each other is unspecified and should not be relied upon.
 * 
 * # Serialization
 * 
 * To handle the inverse scenario of `convert` there is the `serialize` method. This
 * method is called to produce the value to send to a server based on the internal value
 * as would be returned from `convert`. In most cases, these methods should "round trip"
 * a value:
 * 
 *      assertEqual(value, field.serialize(field.convert(value)));
 * 
 * By default, only `Ext.data.field.Date` fields have a `serialize` method.
 * Other types simply send their value unmodified.
 * 
 * # Custom Types
 * 
 * Developers may create their own application-specific data types by deriving from this
 * class. This is typically much better than applying multiple configuration values on
 * field instances as these often become repetitive.
 * 
 * To illustrate, we define a "time" field type that stores a time-of-day represented as a
 * number of minutes since Midnight.
 * 
 *      Ext.define('App.field.Time', {
 *          extend: 'Ext.data.field.Field',
 * 
 *          alias: 'data.field.time',
 * 
 *          timeFormat: 'g:i',
 * 
 *          convert: function (value) {
 *              if (value && Ext.isString(value)) {
 *                  var date = Ext.Date.parse(value, this.timeFormat);
 *                  if (!date) {
 *                      return null;
 *                  }
 *                  return (date.getHours() - 1) * 60 + date.getMinutes();
 *              }
 *              return value;
 *          }
 *      });
 * 
 * ## Validation
 * 
 * Custom field types can override the `validate` method or
 * provide a set of `validators`.
 * 
 *      Ext.define('App.field.PhoneNumber', {
 *          extend: 'Ext.data.field.Field',
 * 
 *          alias: 'data.field.phonenumber',
 * 
 *          // Match U.S. phone numbers for example purposes
 *          validators: {
 *              type: 'format',
 *              matcher: /\d{3}\-\d{3}\-\d{4}/
 *          }
 *      });
 * 
 * Once the class is defined, fields can be declared using the new type (based on its
 * `alias`) like so:
 * 
 *      Ext.define('App.model.PhoneCall', {
 *          fields: [
 *              { name: 'startTime', type: 'time' },
 *              { name: 'phoneNumber', type: 'phonenumber' }
 *          ]
 *      });
 * 
 */
export const auto = 'auto';

export const int = 'int';

export const integer = 'integer';

export const float = 'float';

export const number = 'number';

export const string = 'string';