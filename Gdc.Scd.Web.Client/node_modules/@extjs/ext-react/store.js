
/**
 * 
 * Small helper class to make creating Ext.data.Stores from Array data easier. An ArrayStore will be
 * automatically configured with a Ext.data.reader.Array.
 * 
 * A store configuration would be something like:
 * 
 *     var store = Ext.create('Ext.data.ArrayStore', {
 *         // store configs
 *         storeId: 'myStore',
 *         // reader configs
 *         fields: [
 *            'company',
 *            {name: 'price', type: 'float'},
 *            {name: 'change', type: 'float'},
 *            {name: 'pctChange', type: 'float'},
 *            {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
 *         ]
 *     });
 * 
 * This store is configured to consume a returned object of the form:
 * 
 *     var myData = [
 *         ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
 *         ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
 *         ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
 *         ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
 *         ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
 *     ];
 * 
 * An object literal of this form could also be used as the cfg-data config option.
 * 
 */
export const array = 'array';

/**
 * 
 * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
 * 
 * **Note:** Buffered Stores are not available in the modern toolkit. Instead use
 * `Ext.data.virtual.Store`.
 * 
 * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
 * preclude caching the entire dataset in a regular Ext.data.Store.
 * 
 * When using a BufferedStore *not all of the dataset is present in the client*. Only pages which have been
 * requested by the UI (usually a GridPanel) and surrounding pages will be present. Retention
 * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See leadingBufferZone,
 * trailingBufferZone and purgePageCount.
 * 
 * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
 * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
 * requested and cached.
 * Example:
 * 
 *     myBufferedStore.loadPage(1); // Load page 1
 * 
 * A BufferedRenderer is instantiated which will monitor the scrolling in the grid, and
 * refresh the view's rows from the page cache as needed. It will also pull new data into the page
 * cache when scrolling of the view draws upon data near either end of the prefetched data.
 * 
 * The margins which trigger view refreshing from the prefetched data are Ext.grid.plugin.BufferedRenderer#numFromEdge,
 * Ext.grid.plugin.BufferedRenderer#leadingBufferZone and Ext.grid.plugin.BufferedRenderer#trailingBufferZone.
 * 
 * The margins which trigger loading more data into the page cache are, leadingBufferZone and
 * trailingBufferZone.
 * 
 * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
 * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
 * purgePageCount setting.
 * 
 * Setting this value to zero means that no pages are *ever* scrolled out of the page cache, and
 * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
 * as long as datasets do not reach astronomical proportions.
 * 
 * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
 * records from its collection when those Records cycle out of the Store's primary collection. This is done
 * by configuring the SelectionModel like this:
 * 
 *     selModel: {
 *         pruneRemoved: false
 *     }
 * 
 */
export const buffered = 'buffered';

/**
 * 
 * A chained store is a store that is a "view" of an existing store. The data comes from the
 * source, however this view of the store may be sorted & filtered independently without
 * having any impact on the source store.
 * 
 */
export const chained = 'chained';

/**
 * 
 * Small helper class to create an Ext.data.Store configured with an Ext.data.proxy.Direct
 * and Ext.data.reader.Json to make interacting with an Ext.direct.Manager server-side
 * Provider easier. To create a different proxy/reader combination create a basic
 * Ext.data.Store configured as needed.
 * 
 * **Note:** Although they are not listed, this class inherits all of the config options of:
 * 
 * - **Ext.data.Store**
 * 
 * - **Ext.data.reader.Json**
 * 
 *   - **rootProperty**
 *   - **totalProperty**
 * 
 * - **Ext.data.proxy.Direct**
 * 
 *   - **directFn**
 *   - **paramOrder**
 *   - **paramsAsHash**
 * 
 */
export const direct = 'direct';

/**
 * 
 * Small helper class to make creating Ext.data.Stores from different domain JSON
 * data easier.
 * 
 * A JsonPStore will be automatically configured with a Ext.data.reader.Json and a
 * Ext.data.proxy.JsonP.
 * 
 * A store configuration would be something like:
 * 
 *    var store = new Ext.data.JsonPStore({
 *        // store configs
 *        storeId: 'myStore',
 * 
 *        // proxy configs
 *        url: 'get-images.php',
 * 
 *        // reader configs
 *        root: 'images',
 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
 *    });
 * 
 * 
 * This store is configured to consume a returned object of the form:
 * 
 *    stcCallback({
 *        images: [
 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
 *        ]
 *    })
 * 
 * Where stcCallback is the callback name passed in the request to the remote domain. See {
 * 
 * An object literal of this form could also be used as the cfg-data config option.
 * 
 */
export const jsonp = 'jsonp';

/**
 * 
 * Small helper class to make creating Ext.data.Stores from JSON data easier.
 * A JsonStore will be automatically configured with a Ext.data.reader.Json.
 * 
 * A store configuration would be something like:
 * 
 *     var store = new Ext.data.JsonStore({
 *         // store configs
 *         storeId: 'myStore',
 * 
 *         proxy: {
 *             type: 'ajax',
 *             url: 'get-images.php',
 *             reader: {
 *                 type: 'json',
 *                 rootProperty: 'images'
 *             }
 *         },
 * 
 *         //alternatively, a Model name can be given (see Ext.data.Store for an example)
 *         fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
 *     });
 * 
 * This store is configured to consume a returned object of the form:
 * 
 *     {
 *         images: [
 *             {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
 *             {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
 *         ]
 *     }
 * 
 * An object literal of this form could also be used as the cfg-data config option.
 * 
 */
export const json = 'json';

/**
 * 
 * Node Store
 * 
 */
export const node = 'node';

/**
 * 
 * The Store class encapsulates a client side cache of Ext.data.Model objects. Stores load data via a
 * Ext.data.proxy.Proxy, and also provide functions for sorting, filtering
 * and querying the Ext.data.Model instances contained within it.
 * 
 * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
 * 
 *      // Set up a model to use in our Store
 *      Ext.define('User', {
 *          extend: 'Ext.data.Model',
 *          fields: [
 *              {name: 'firstName', type: 'string'},
 *              {name: 'lastName',  type: 'string'},
 *              {name: 'age',       type: 'int'},
 *              {name: 'eyeColor',  type: 'string'}
 *          ]
 *      });
 * 
 *      let myStore = new Ext.data.Store({
 *          model: 'User',
 *          proxy: {
 *              type: 'ajax',
 *              url: '/users.json',
 *              reader: {
 *                  type: 'json',
 *                  rootProperty: 'users'
 *              }
 *          },
 *          autoLoad: true
 *      });
 * 
 * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
 * Ext.data.reader.Json to parse the response from the server into Model object - Ext.data.reader.Json for details.
 * 
 * ## Inline data
 * 
 * Stores can also load data inline. Internally, Store converts each of the objects we pass in as cfg-data into
 * Model instances:
 * 
 *      new Ext.data.Store({
 *          model: 'User',
 *          data : [
 *              {firstName: 'Peter',   lastName: 'Venkman'},
 *              {firstName: 'Egon',    lastName: 'Spengler'},
 *              {firstName: 'Ray',     lastName: 'Stantz'},
 *              {firstName: 'Winston', lastName: 'Zeddemore'}
 *          ]
 *      });
 * 
 * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
 * need to be processed by a Ext.data.reader.Reader). If your inline data requires processing to decode
 * the data structure, use a Ext.data.proxy.Memory instead (see the Ext.data.proxy.Memory docs for an example).
 * 
 * Additional data can also be loaded locally using method-add.
 * 
 * ## Dynamic Loading
 * 
 * Stores can be dynamically updated by calling the method-load method:
 * 
 *     store.load({
 *         params: {
 *             group: 3,
 *             type: 'user'
 *         },
 *         callback: function(records, operation, success) {
 *             // do something after the load finishes
 *         },
 *         scope: this
 *     });
 * 
 * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
 * up to do something after the loading is over.
 * 
 * ## Loading Nested Data
 * 
 * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
 * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
 * the Ext.data.reader.Reader intro docs for a full explanation:
 * 
 *      let store = new Ext.data.Store({
 *          autoLoad: true,
 *          model: "User",
 *          proxy: {
 *              type: 'ajax',
 *              url: 'users.json',
 *              reader: {
 *                  type: 'json',
 *                  rootProperty: 'users'
 *              }
 *          }
 *      });
 * 
 * Which would consume a response like this:
 * 
 *      {
 *          "users": [{
 *              "id": 1,
 *              "name": "Peter",
 *              "orders": [{
 *                  "id": 10,
 *                  "total": 10.76,
 *                  "status": "invoiced"
 *             },{
 *                  "id": 11,
 *                  "total": 13.45,
 *                  "status": "shipped"
 *             }]
 *          }]
 *      }
 * 
 * See the Ext.data.reader.Reader intro docs for a full explanation.
 * 
 * ## Filtering and Sorting
 * 
 * Stores can be sorted and filtered - in both cases either remotely or locally. The cfg-sorters and
 * cfg-filters are held inside Ext.util.Collection instances to make them easy to manage.
 * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call method-sort
 * or filter:
 * 
 *      let store = new Ext.data.Store({
 *          model: 'User',
 *          sorters: [{
 *              property: 'age',
 *              direction: 'DESC'
 *          }, {
 *              property: 'firstName',
 *              direction: 'ASC'
 *          }],
 * 
 *          filters: [{
 *              property: 'firstName',
 *              value: /Peter/
 *          }]
 *      });
 * 
 * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
 * default, sorting and filtering are both performed locally by the Store - see remoteSort and
 * remoteFilter to allow the server to perform these operations instead.
 * 
 * Filtering and sorting after the Store has been instantiated is also easy. Calling filter adds another filter
 * to the Store and automatically filters the dataset (calling filter with no arguments simply re-applies all
 * existing filters).
 * 
 *     store.filter('eyeColor', 'Brown');
 * 
 * Change the sorting at any time by calling method-sort:
 * 
 *     store.sort('height', 'ASC');
 * 
 * Note that all existing sorters will be removed in favor of the new sorter data (if method-sort is called with no
 * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
 * ones, just add them to the Collection:
 * 
 *     store.sorters.add(new Ext.util.Sorter({
 *         property : 'shoeSize',
 *         direction: 'ASC'
 *     }));
 * 
 *     store.sort();
 * 
 * ## Registering with StoreManager
 * 
 * Any Store that is instantiated with a storeId will automatically be registered with the Ext.data.StoreManager. This makes it easy to reuse the same store in multiple views:
 * 
 *     //this store can be used several times
 *     new Ext.data.Store({
 *         model: 'User',
 *         storeId: 'usersStore'
 *     });
 * 
 *     new Ext.List({
 *         store: 'usersStore',
 *         //other config goes here
 *     });
 * 
 *     new Ext.view.View({
 *         store: 'usersStore',
 *         //other config goes here
 *     });
 * 
 * ## Further Reading
 * 
 * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
 * pieces and how they fit together, see:
 * 
 *   - Ext.data.proxy.Proxy - overview of what Proxies are and how they are used
 *   - Ext.data.Model - the core class in the data package
 *   - Ext.data.reader.Reader - used by any subclass of Ext.data.proxy.Server to read a response
 * 
 */
export const store = 'store';

/**
 * 
 * The TreeStore is a store implementation that owns the node of
 * a tree, and provides methods to load either local or remote data as child nodes of the root
 * and any descendant non-leaf node.
 * 
 * The TreeStore must be used as the store of a panel.
 * 
 * This class also relays many node events from the underlying node structure.
 * 
 * # Using Models
 * 
 * If no Model is specified, an implicit model will be created that extends Ext.data.TreeModel.
 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
 * in the Ext.data.NodeInterface documentation.
 * 
 * # Reading Nested Data
 * 
 * For the tree to read nested data, the Ext.data.reader.Reader must be configured with a root property,
 * so the reader can find nested data for each node (if a root is not specified, it will default to
 * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
 * If a root is specified in the config make sure that any nested nodes with children have the same name.
 * 
 * **Note:** Setting defaultRootProperty accomplishes the same thing.
 * 
 * #rootProperty as a Function
 * You can pass a function as the data reader's rootProperty when the tree's dataset has
 * mixed root properties. Child nodes can then be programmatically determined at read time.
 * 
 * For example, the child nodes may be passed via the 'children' property
 * name, though you may have a top-level root property of 'items'.
 * 
 * See rootProperty for more information.
 * 
 * #Filtering#
 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
 * pass the filter, then it, and all its descendants are filtered *out* of the store.
 * 
 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
 * the `TreeStore` with ''bottomup'`
 * 
 * You may also programatically filter individual tree nodes by setting their `'visible'` field.
 * 
 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
 * filters the node in.
 * 
 * Note that if performing several filter operations, it is best to method-suspendEvents
 * on the store first, and when all nodes have been modified, method-resumeEvents and fire the
 * event-refresh event on the store.
 * 
 */
export const tree = 'tree';

/**
 * 
 * This type of store is a replacement for BufferedStore at least for Modern. The primary
 * use of this store is to create and manage "active ranges" of records.
 * 
 * For example:
 * 
 *      var range = store.createActiveRange({
 *          begin: 100,
 *          end: 200,
 *          prefetch: true,  // allow prefetching beyond range
 *          callback: 'onRangeUpdate',
 *          scope: this
 *      });
 * 
 *      // Navigate to a different range. This will causes pages to load and
 *      // the onRangeUpdate method will be called as the load(s) progress.
 *      // This can change the length or number of records spanned on each
 *      // call.
 *      //
 *      range.goto(300, 400);
 * 
 *      onRangeUpdate: function (range, begin, end) {
 *          // Called when records appear in the range...
 *          // We can check if all things are loaded:
 * 
 *          // Or we can use range.records (sparsely populated)
 *      }
 * 
 */
export const virtual = 'virtual';

/**
 * 
 * Small helper class to make creating Ext.data.Stores from XML data easier.
 * An XmlStore will be automatically configured with a Ext.data.reader.Xml.
 * 
 * A store configuration would be something like:
 * 
 *     var store = new Ext.data.XmlStore({
 *         // store configs
 *         storeId: 'myStore',
 *         url: 'sheldon.xml', // automatically configures a HttpProxy
 * 
 *         // reader configs
 *         record: 'Item', // records will have an "Item" tag
 *         idPath: 'ASIN',
 *         totalRecords: '@TotalResults'
 * 
 *         fields: [
 *             // set up the fields mapping into the xml doc
 *             // The first needs mapping, the others are very basic
 *             {name: 'Author', mapping: 'ItemAttributes > Author'},
 *             'Title', 'Manufacturer', 'ProductGroup'
 *         ]
 *     });
 * 
 * This store is configured to consume a returned object of the form:
 * 
 *      <?xml version="1.0" encoding="UTF-8"?>
 *      <ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
 *          <Items>
 *              <Request>
 *                  <IsValid>True</IsValid>
 *                  <ItemSearchRequest>
 *                      <Author>Sidney Sheldon</Author>
 *                      <SearchIndex>Books</SearchIndex>
 *                  </ItemSearchRequest>
 *              </Request>
 *              <TotalResults>203</TotalResults>
 *              <TotalPages>21</TotalPages>
 *              <Item>
 *                  <ASIN>0446355453</ASIN>
 *                  <DetailPageURL>
 *                      http://www.amazon.com/
 *                  </DetailPageURL>
 *                  <ItemAttributes>
 *                      <Author>Sidney Sheldon</Author>
 *                      <Manufacturer>Warner Books</Manufacturer>
 *                      <ProductGroup>Book</ProductGroup>
 *                      <Title>Master of the Game</Title>
 *                  </ItemAttributes>
 *              </Item>
 *          </Items>
 *      </ItemSearchResponse>
 * 
 * An object literal of this form could also be used as the cfg-data config option.
 * **Note:** This class accepts all of the configuration options of Ext.data.reader.Xml.
 * 
 */
export const xml = 'xml';