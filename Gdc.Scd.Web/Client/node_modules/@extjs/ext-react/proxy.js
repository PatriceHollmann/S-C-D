
/**
 * 
 * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
 * data from the server, usually to be placed into a Ext.data.Store. Let's take a look at a typical setup.
 * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a Ext.data.Model:
 * 
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: ['id', 'name', 'email']
 *     });
 * 
 *     //The Store contains the AjaxProxy as an inline configuration
 *     let store = new Ext.data.Store({
 *         model: 'User',
 *         proxy: {
 *             type: 'ajax',
 *             url : 'users.json'
 *         }
 *     });
 * 
 *     store.load();
 * 
 * Our example is going to load user data into a Store, so we start off by defining a Ext.data.Model with
 * the fields that we expect the server to return. Next we set up the Store itself, along with a
 * proxy configuration. This configuration was automatically turned into an
 * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
 * It's as if we'd done this:
 * 
 *     new Ext.data.proxy.Ajax({
 *         url: 'users.json',
 *         model: 'User',
 *         reader: 'json'
 *     });
 * 
 * A couple of extra configurations appeared here - model and reader. These are set by default when we
 * create the proxy via the Store - the Store already knows about the Model, and Proxy's default Ext.data.reader.Reader is Ext.data.reader.Json.
 * 
 * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
 * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
 * actionMethods to customize this - by default any kind of read will be sent as a GET request and any kind of write
 * will be sent as a POST request).
 * 
 * # Limitations
 * 
 * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
 * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
 * talking to each other via AJAX.
 * 
 * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
 * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
 * from http://domainA.com), you can use Ext.data.proxy.JsonP and a technique known as JSON-P (JSON with
 * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
 * JSON-P responses. See Ext.data.proxy.JsonP's introduction docs for more details.
 * 
 * # Readers and Writers
 * 
 * AjaxProxy can be configured to use any type of Ext.data.reader.Reader to decode the server's response.
 * If no Reader is supplied, AjaxProxy will default to using a Ext.data.reader.Json. Reader
 * configuration can be passed in as a simple object, which the Proxy automatically turns into a Ext.data.reader.Reader instance:
 * 
 *     var proxy = new Ext.data.proxy.Ajax({
 *         model: 'User',
 *         reader: {
 *             type: 'xml',
 *             rootProperty: 'users'
 *         }
 *     });
 * 
 *     proxy.getReader(); //returns an XmlReader instance based on the config we supplied
 * 
 * # Url generation
 * 
 * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
 * each request. These are controlled with the following configuration options:
 * 
 * - pageParam - controls how the page number is sent to the server (see also startParam and limitParam)
 * - sortParam - controls how sort information is sent to the server
 * - groupParam - controls how grouping information is sent to the server
 * - filterParam - controls how filter information is sent to the server
 * 
 * Each request sent by AjaxProxy is described by an Ext.data.operation.Operation. To see how we can customize
 * the generated urls, let's say we're loading the Proxy with the following Operation:
 * 
 *     var proxy = new Ext.data.proxy.Ajax({
 *         url: '/users'
 *     });
 * 
 *     var operation = proxy.createOperation('read', {
 *         page  : 2
 *     });
 * 
 * Now we'll issue the request for this Operation by calling read:
 * 
 *     proxy.read(operation); //GET /users?page=2
 * 
 * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
 * to the server:
 * 
 *     var proxy = new Ext.data.proxy.Ajax({
 *         url: '/users',
 *         pageParam: 'pageNumber'
 *     });
 * 
 *     proxy.read(operation); //GET /users?pageNumber=2
 * 
 * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
 * 
 *     var proxy = new Ext.data.proxy.Ajax({
 *         url: '/users'
 *     });
 * 
 *     var operation = proxy.createOperation('read', {
 *         start : 50,
 *         limit : 25
 *     });
 * 
 *     proxy.read(operation); //GET /users?start=50&limit;=25
 * 
 * Again we can customize this url:
 * 
 *     var proxy = new Ext.data.proxy.Ajax({
 *         url: '/users',
 *         startParam: 'startIndex',
 *         limitParam: 'limitIndex'
 *     });
 * 
 *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
 * 
 * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
 * expressive Operation object:
 * 
 *     var operation = proxy.createOperation('read', {
 *         sorters: [
 *             new Ext.util.Sorter({
 *                 property : 'name',
 *                 direction: 'ASC'
 *             }),
 *             new Ext.util.Sorter({
 *                 property : 'age',
 *                 direction: 'DESC'
 *             })
 *         ],
 *         filters: [
 *             new Ext.util.Filter({
 *                 property: 'eyeColor',
 *                 value   : 'brown'
 *             })
 *         ]
 *     });
 * 
 * This is the type of object that is generated internally when loading a Ext.data.Store with sorters and
 * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
 * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
 * 
 *     var proxy = new Ext.data.proxy.Ajax({
 *         url: '/users'
 *     });
 * 
 *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
 * 
 * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
 * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
 * that format like this:
 * 
 *      var proxy = new Ext.data.proxy.Ajax({
 *          url: '/users',
 *          sortParam: 'sortBy',
 *          filterParam: 'filterBy',
 * 
 *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
 *          encodeSorters: function(sorters) {
 *              var length   = sorters.length,
 *                  sortStrs = [],
 *                  sorter, i;
 * 
 *              for (i = 0; i < length; i++) {
 *                  sorter = sorters[i];
 * 
 *                  sortStrs[i] = sorter.property + '#' + sorter.direction
 *              }
 * 
 *              return sortStrs.join(",");
 *          }
 *      });
 * 
 *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
 * 
 * We can also provide a custom encodeFilters function to encode our filters.
 * 
 * # Debugging your Ajax Proxy
 * 
 * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the reader
 * is configured, and the shape of the incoming data.
 * 
 * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
 * created in the `createRequestCallback` method of the Ajax Proxy class, and follow the data to where the reader attempts
 * to consume it.
 * 
 */
export const ajax = 'ajax';

/**
 * 
 * This class is used to send requests to the server using Direct.
 * When a request is made, the transport mechanism is handed off to the appropriate
 * Provider to complete the call.
 * 
 * # Specifying the functions
 * 
 * This proxy expects Direct remoting method to be passed in order to be able to complete requests,
 * one Direct function per CRUD method. This is done via api configuration:
 * 
 *      api: {
 *          read: 'MyApp.readRecords',
 *          create: 'MyApp.createRecords',
 *          update: 'MyApp.updateRecords',
 *          destroy: 'MyApp.destroyRecords'
 *      }
 * 
 * You can also use a `prefix` config to avoid duplicating full namespaces for Direct functions:
 * 
 *      api: {
 *          prefix: 'MyApp',
 *          read: 'readRecords',
 *          create: 'createRecords',
 *          update: 'updateRecords',
 *          destroy: 'destroyRecords'
 *      }
 * 
 * The preferred way is to specify function names to allow late resolution, however you can
 * pass function references instead if desired:
 * 
 *      api: {
 *          read: MyApp.readRecords,
 *          create: MyApp.createRecords,
 *          update: MyApp.updateRecords,
 *          destroy: MyApp.destroyRecords
 *      }
 * 
 * This method of configuring API is not recommended because this way the Direct functions
 * need to be created very early in the application lifecycle, long before Ext.app.Application
 * instance is initialized.
 * 
 * You can also use the directFn configuration instead of api. This will use
 * the same Direct function for all types of requests.
 * 
 * # Server API
 * 
 * The server side methods are expected to conform to the following calling conventions:
 * 
 * ## `read`
 * 
 * Accept one argument which is either named arguments in an object (default), or an array
 * of values depending on the paramsAsHash configuration. Return an array of records
 * or an object with format recognizable by the configured Ext.data.reader.Reader
 * instance.
 * 
 * Example declaration:
 * 
 *      actions: {
 *          MyApp: [{
 *              name: 'readRecords',
 *              params: [],
 *              strict: false
 *          }]
 *      }
 * 
 * Example function invocation:
 * 
 *      MyApp.readRecords(
 *          {
 *              start: 0,
 *              limit: 10
 *          },
 *          // Results are passed to the callback function
 *          function(records) {
 *              console.log(records);
 *              // Logs:  [{ id: 'r0', text: 'foo' }, { id: 'r1', text: 'bar' }]
 *          }
 *      );
 * 
 * ## `create`
 * 
 * Accept one ordered argument which is either an object with data for the new record,
 * or an array of objects for multiple records. Return an array of identifiers for actually
 * created records. See Ext.data.Model#clientIdProperty for more information.
 * 
 * Example declaration:
 * 
 *      actions: [
 *          MyApp: [{
 *              name: 'createRecords',
 *              len: 1
 *          }]
 *      }
 * 
 * Example function invocation:
 * 
 *      MyApp.createRecords(
 *          [
 *              { id: 0, text: 'foo' },
 *              { id: 1, text: 'bar' }
 *          ],
 *          // Results are passed to the callback function
 *          function(records) {
 *              console.log(records);
 *              // Logs: [{ clientId: 0, id: 'r0' }, { clientId: 1, id: 'r1' }]
 *          }
 *      );
 * 
 * ## `update`
 * 
 * Accept one ordered argument which is either an object with updated data and valid
 * record identifier, or an array of objects for multiple records. Return an array of
 * objects with updated record data.
 * 
 * Example declaration:
 * 
 *      actions: [
 *          MyApp: [{
 *              name: 'updateRecords',
 *              len: 1
 *          }]
 *      }
 * 
 * Example function invocation:
 * 
 *      MyApp.updateRecords(
 *          [
 *              { id: 'r0', text: 'blerg' },
 *              { id: 'r1', text: 'throbbe' }
 *          ],
 *          // Results are passed to the callback function
 *          function(records) {
 *              console.log(records);
 *              // Logs: [{ id: 'r0', text: 'blerg' }, { id: 'r1', text: 'throbbe }]
 *          }
 *      );
 * 
 * ## `destroy`
 * 
 * Accept one ordered argument which is an array of record identifiers to be deleted.
 * Return an object with at least one Ext.data.reader.Json#successProperty
 * property set to `true` or `false`, with more optional properties recognizable by configured
 * Ext.data.reader.Reader instance.
 * 
 * Example declaration:
 * 
 *      actions: [
 *          MyApp: [{
 *              name: 'destroyRecords',
 *              len: 1
 *          }]
 *      }
 * 
 * Example function invocation:
 * 
 *      MyApp.destroyRecords(
 *          [
 *              { id: 'r0' },
 *              { id: 'r1' }
 *          ],
 *          // Results are passed to the callback function
 *          function(result) {
 *              // Default successProperty is `success`
 *              if (!result.success) {
 *                  // Handle the error
 *              }
 *          }
 *      );
 * 
 * ## Read method parameters
 * 
 * Direct proxy provides options to help configure which parameters will be sent to the server
 * for Read operations. By setting the paramsAsHash option to `true`, the proxy will
 * send an object literal containing each of the passed parameters. This is the default. When
 * paramsAsHash is set to `false`, Proxy will pass the Read function an array of values
 * instead of an object, with the order determined by paramOrder value.
 * 
 * Setting paramOrder to any value other than `undefined` will automatically reset
 * paramsAsHash to `false`.
 * 
 * # Example Usage
 * 
 *      Ext.define('User', {
 *          extend: 'Ext.data.Model',
 *          fields: ['firstName', 'lastName']
 *      });
 * 
 *      Ext.define('Users', {
 *          extend: 'Ext.data.Store',
 *          model: 'User',
 *          proxy: {
 *              type: 'direct',
 *              directFn: 'MyApp.getUsers',
 *              // Tells the proxy to pass `start` and `limit` as two by-position arguments:
 *              paramOrder: 'start,limit'
 *          }
 *      });
 * 
 *      var store = new Users();
 *      store.load();
 * 
 */
export const direct = 'direct';

/**
 * 
 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
 * your application is running on http://domainA.com it cannot use Ext.data.proxy.Ajax to load its data
 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
 * 
 * We can get around this using a JsonP proxy. JsonP proxy injects a `<script>` tag into the DOM whenever an AJAX request
 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
 * injected might look like this:
 * 
 *     <script src="http://domainB.com/users?callback=someCallback"></script>
 * 
 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
 * long as the server formats the response to look like this, everything will work:
 * 
 *     someCallback({
 *         users: [
 *             {
 *                 id: 1,
 *                 name: "Ed Spencer",
 *                 email: "ed@sencha.com"
 *             }
 *         ]
 *     });
 * 
 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
 * object that the server returned.
 * 
 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
 * the Proxy making it look just like you loaded it through a normal Ext.data.proxy.Ajax. Here's how
 * we might set that up:
 * 
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: ['id', 'name', 'email']
 *     });
 * 
 *     let store = new Ext.data.Store({
 *         model: 'User',
 *         proxy: {
 *             type: 'jsonp',
 *             url : 'http://domainB.com/users'
 *         }
 *     });
 * 
 *     store.load();
 * 
 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
 * like this:
 * 
 *     <script src="http://domainB.com/users?callback=callback1"></script>
 * 
 * # Customization
 * 
 * This script tag can be customized using the callbackKey configuration. For example:
 * 
 *     let store = new Ext.data.Store({
 *         model: 'User',
 *         proxy: {
 *             type: 'jsonp',
 *             url : 'http://domainB.com/users',
 *             callbackKey: 'theCallbackFunction'
 *         }
 *     });
 * 
 *     store.load();
 * 
 * Would inject a script tag like this:
 * 
 *     <script src="http://domainB.com/users?theCallbackFunction=callback1"></script>
 * 
 * # Implementing on the server side
 * 
 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
 * achieve this using Java, PHP and ASP.net:
 * 
 * Java:
 * 
 *     boolean jsonP = false;
 *     String cb = request.getParameter("callback");
 *     if (cb != null) {
 *         jsonP = true;
 *         response.setContentType("text/javascript");
 *     } else {
 *         response.setContentType("application/x-json");
 *     }
 *     Writer out = response.getWriter();
 *     if (jsonP) {
 *         out.write(cb + "(");
 *     }
 *     out.print(dataBlock.toJsonString());
 *     if (jsonP) {
 *         out.write(");");
 *     }
 * 
 * PHP:
 * 
 *     $callback = $_REQUEST['callback'];
 * 
 *     // Create the output object.
 *     $output = array('a' => 'Apple', 'b' => 'Banana');
 * 
 *     //start output
 *     if ($callback) {
 *         header('Content-Type: text/javascript');
 *         echo $callback . '(' . json_encode($output) . ');';
 *     } else {
 *         header('Content-Type: application/x-json');
 *         echo json_encode($output);
 *     }
 * 
 * ASP.net:
 * 
 *     String jsonString = "{success: true}";
 *     String cb = Request.Params.Get("callback");
 *     String responseString = "";
 *     if (!String.IsNullOrEmpty(cb)) {
 *         responseString = cb + "(" + jsonString + ")";
 *     } else {
 *         responseString = jsonString;
 *     }
 *     Response.Write(responseString);
 * 
 */
export const jsonp = 'jsonp';

/**
 * 
 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
 * your application is running on http://domainA.com it cannot use Ext.data.proxy.Ajax to load its data
 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
 * 
 * We can get around this using a JsonP proxy. JsonP proxy injects a `<script>` tag into the DOM whenever an AJAX request
 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
 * injected might look like this:
 * 
 *     <script src="http://domainB.com/users?callback=someCallback"></script>
 * 
 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
 * long as the server formats the response to look like this, everything will work:
 * 
 *     someCallback({
 *         users: [
 *             {
 *                 id: 1,
 *                 name: "Ed Spencer",
 *                 email: "ed@sencha.com"
 *             }
 *         ]
 *     });
 * 
 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
 * object that the server returned.
 * 
 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
 * the Proxy making it look just like you loaded it through a normal Ext.data.proxy.Ajax. Here's how
 * we might set that up:
 * 
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: ['id', 'name', 'email']
 *     });
 * 
 *     let store = new Ext.data.Store({
 *         model: 'User',
 *         proxy: {
 *             type: 'jsonp',
 *             url : 'http://domainB.com/users'
 *         }
 *     });
 * 
 *     store.load();
 * 
 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
 * like this:
 * 
 *     <script src="http://domainB.com/users?callback=callback1"></script>
 * 
 * # Customization
 * 
 * This script tag can be customized using the callbackKey configuration. For example:
 * 
 *     let store = new Ext.data.Store({
 *         model: 'User',
 *         proxy: {
 *             type: 'jsonp',
 *             url : 'http://domainB.com/users',
 *             callbackKey: 'theCallbackFunction'
 *         }
 *     });
 * 
 *     store.load();
 * 
 * Would inject a script tag like this:
 * 
 *     <script src="http://domainB.com/users?theCallbackFunction=callback1"></script>
 * 
 * # Implementing on the server side
 * 
 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
 * achieve this using Java, PHP and ASP.net:
 * 
 * Java:
 * 
 *     boolean jsonP = false;
 *     String cb = request.getParameter("callback");
 *     if (cb != null) {
 *         jsonP = true;
 *         response.setContentType("text/javascript");
 *     } else {
 *         response.setContentType("application/x-json");
 *     }
 *     Writer out = response.getWriter();
 *     if (jsonP) {
 *         out.write(cb + "(");
 *     }
 *     out.print(dataBlock.toJsonString());
 *     if (jsonP) {
 *         out.write(");");
 *     }
 * 
 * PHP:
 * 
 *     $callback = $_REQUEST['callback'];
 * 
 *     // Create the output object.
 *     $output = array('a' => 'Apple', 'b' => 'Banana');
 * 
 *     //start output
 *     if ($callback) {
 *         header('Content-Type: text/javascript');
 *         echo $callback . '(' . json_encode($output) . ');';
 *     } else {
 *         header('Content-Type: application/x-json');
 *         echo json_encode($output);
 *     }
 * 
 * ASP.net:
 * 
 *     String jsonString = "{success: true}";
 *     String cb = Request.Params.Get("callback");
 *     String responseString = "";
 *     if (!String.IsNullOrEmpty(cb)) {
 *         responseString = cb + "(" + jsonString + ")";
 *     } else {
 *         responseString = jsonString;
 *     }
 *     Response.Write(responseString);
 * 
 */
export const scripttag = 'scripttag';

/**
 * The LocalStorageProxy uses the new HTML5 localStorage API to save Ext.data.Model data locally on the
 * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
 * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
 * 
 * localStorage is extremely useful for saving user-specific information without needing to build server-side
 * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
 * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
 * 
 *     Ext.define('Search', {
 *         fields: ['id', 'query'],
 *         extend: 'Ext.data.Model',
 *         proxy: {
 *             type: 'localstorage',
 *             id  : 'twitter-Searches'
 *         }
 *     });
 * 
 * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
 * pass to the LocalStorage proxy is an id. This is important as it separates the Model data in this Proxy from
 * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
 * LocalStorageProxy to manage the saved Search data.
 * 
 * Saving our data into localStorage is easy and would usually be done with a Ext.data.Store:
 * 
 *     //our Store automatically picks up the LocalStorageProxy defined on the Search model
 *     let store = new Ext.data.Store({
 *         model: "Search"
 *     });
 * 
 *     //loads any existing Search data from localStorage
 *     store.load();
 * 
 *     //now add some Searches
 *     store.add({query: 'Sencha Touch'});
 *     store.add({query: 'Ext JS'});
 * 
 *     //finally, save our Search data to localStorage
 *     store.sync();
 * 
 * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
 * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
 * 
 *     var search = Ext.create('Search', {query: 'Sencha Animator'});
 * 
 *     //uses the configured LocalStorageProxy to save the new Search to localStorage
 *     search.save();
 * 
 * # Limitations
 * 
 * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
 * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
 * object.
 * 
 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
 * 
 */
export const localstorage = 'localstorage';

/**
 * 
 * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
 * every page refresh.
 * 
 * Usually this Proxy isn't used directly, serving instead as a helper to a Ext.data.Store where a reader
 * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
 * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
 * Store:
 * 
 *     //this is the model we will be using in the store
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: [
 *             {name: 'id',    type: 'int'},
 *             {name: 'name',  type: 'string'},
 *             {name: 'phone', type: 'string', mapping: 'phoneNumber'}
 *         ]
 *     });
 * 
 *     //this data does not line up to our model fields - the phone field is called phoneNumber
 *     var data = {
 *         users: [
 *             {
 *                 id: 1,
 *                 name: 'Ed Spencer',
 *                 phoneNumber: '555 1234'
 *             },
 *             {
 *                 id: 2,
 *                 name: 'Abe Elias',
 *                 phoneNumber: '666 1234'
 *             }
 *         ]
 *     };
 * 
 *     //note how we set the 'root' in the reader to match the data structure above
 *     let store = new Ext.data.Store({
 *         autoLoad: true,
 *         model: 'User',
 *         data : data,
 *         proxy: {
 *             type: 'memory',
 *             reader: {
 *                 type: 'json',
 *                 rootProperty: 'users'
 *             }
 *         }
 *     });
 * 
 */
export const memory = 'memory';

/**
 * 
 * Proxies are used by Ext.data.Store to handle the loading and saving of Ext.data.Model
 * data. Usually developers will not need to create or interact with proxies directly.
 * 
 * # Types of Proxy
 * 
 * There are two main types of Proxy - Ext.data.proxy.Client and Ext.data.proxy.Server.
 * The Client proxies save their data locally and include the following subclasses:
 * 
 * - Ext.data.proxy.LocalStorage - saves its data to localStorage if the browser supports it
 * - Ext.data.proxy.SessionStorage - saves its data to sessionStorage if the browsers supports it
 * - Ext.data.proxy.Memory - holds data in memory only, any data is lost when the page is refreshed
 * 
 * The Server proxies save their data by sending requests to some remote server. These proxies include:
 * 
 * - Ext.data.proxy.Ajax - sends requests to a server on the same domain
 * - Ext.data.proxy.JsonP - uses JSON-P to send requests to a server on a different domain
 * - Ext.data.proxy.Rest - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
 * - Ext.data.proxy.Direct - uses Ext.direct.Manager to send requests
 * 
 * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
 * operations are mapped to the methods create, read, update and erase
 * respectively. Each Proxy subclass implements these functions.
 * 
 * The CRUD methods each expect an Ext.data.operation.Operation object as the sole argument. The Operation
 * encapsulates information about the action the Store wishes to perform, the Ext.data.Model instances
 * that are to be modified, etc. See the Ext.data.operation.Operation documentation for more details. Each CRUD
 * method also accepts a callback function to be called asynchronously on completion.
 * 
 * Proxies also support batching of Operations via a Ext.data.Batch object, invoked by the batch
 * method.
 * 
 */
export const proxy = 'proxy';

/**
 * 
 * The Rest proxy is a specialization of the Ext.data.proxy.Ajax which simply maps the four actions
 * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a Ext.data.Model
 * with an inline Rest proxy
 * 
 *     Ext.define('User', {
 *         extend: 'Ext.data.Model',
 *         fields: ['id', 'name', 'email'],
 * 
 *         proxy: {
 *             type: 'rest',
 *             url : '/users'
 *         }
 *     });
 * 
 * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
 * request to '/users':
 * 
 *     var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
 * 
 *     user.save(); //POST /users
 * 
 * Let's expand this a little and provide a callback for the Ext.data.Model#save call to update the Model once
 * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
 * 
 *     user.save({
 *         success: function(user) {
 *             user.set('name', 'Khan Noonien Singh');
 * 
 *             user.save(); //PUT /users/123
 *         }
 *     });
 * 
 * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
 * relevant url for that user. Now let's delete this user, which will use the DELETE method:
 * 
 *         user.erase(); //DELETE /users/123
 * 
 * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
 * 
 *     //1. Load via Store
 * 
 *     //the Store automatically picks up the Proxy from the User model
 *     var store = new Ext.data.Store({
 *         model: 'User'
 *     });
 * 
 *     store.load(); //GET /users
 * 
 *     //2. Load directly from the Model
 * 
 *     //GET /users/123
 *     User.load(123, {
 *         success: function(user) {
 *             console.log(user.getId()); //outputs 123
 *         }
 *     });
 * 
 * # Url generation
 * 
 * The Rest proxy is able to automatically generate the urls above based on two configuration options - appendId and
 * format. If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
 * instance in question to the configured url, resulting in the '/users/123' that we saw above.
 * 
 * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
 * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
 * 
 *     new Ext.data.proxy.Rest({
 *         url: '/users',
 *         appendId: true //default
 *     });
 * 
 *     // Collection url: /users
 *     // Instance url  : /users/123
 * 
 * The Rest proxy can also optionally append a format string to the end of any generated url:
 * 
 *     new Ext.data.proxy.Rest({
 *         url: '/users',
 *         format: 'json'
 *     });
 * 
 *     // Collection url: /users.json
 *     // Instance url  : /users/123.json
 * 
 * If further customization is needed, simply implement the buildUrl method and add your custom generated url
 * onto the Ext.data.Request object that is passed to buildUrl. See [Rest proxy's implementation][1] for
 * an example of how to achieve this.
 * 
 * Note that Rest proxy inherits from Ext.data.proxy.Ajax, which already injects all of the sorter,
 * filter, group and paging options into the generated url. See the Ext.data.proxy.Ajax for more
 * details.
 * 
 * [1]: source/Rest.html#Ext-data-proxy-Rest-method-buildUrl
 * 
 */
export const rest = 'rest';

/**
 * ServerProxy is a superclass of Ext.data.proxy.JsonP and Ext.data.proxy.Ajax, and
 * would not usually be used directly.
 * 
 */
export const server = 'server';

/**
 * 
 * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
 * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
 * unique ID which is used as a key in which all record data are stored in the session storage object.
 * 
 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
 * 
 * Proxies are almost always used with a Ext.data.Store:
 * 
 *     new Ext.data.Store({
 *         proxy: {
 *             type: 'sessionstorage',
 *             id  : 'myProxyKey'
 *         }
 *     });
 * 
 * Alternatively you can instantiate the Proxy directly:
 * 
 *     new Ext.data.proxy.SessionStorage({
 *         id  : 'myOtherProxyKey'
 *     });
 * 
 * Note that session storage is different to local storage (see Ext.data.proxy.LocalStorage) - if a browser
 * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
 * don't affect the Ext.data.proxy.LocalStorage - the data are preserved.
 * 
 */
export const sessionstorage = 'sessionstorage';